<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Peak Card Game</title>
    
    <!-- Favicon Links -->
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#667eea">
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/8.0.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.0.0/firebase-database.js"></script>
    <script>
        // Initialize Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyD-ljapIUtza5mrB-apKov6JkX69lKh_wk",
            authDomain: "peakgame-19c4e.firebaseapp.com",
            databaseURL: "https://peakgame-19c4e-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "peakgame-19c4e",
            storageBucket: "peakgame-19c4e.firebasestorage.app",
            messagingSenderId: "654257657143",
            appId: "1:654257657143:web:8e114c0a3df1569bb6f6b2",
            measurementId: "G-TZNJTK79MT"
        };
        
        // Initialize Firebase
        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
            
            // Test database connection (read-only, don't try to write to .info/)
            const connectedRef = firebase.database().ref('.info/connected');
            connectedRef.on('value', (snap) => {
                const isConnected = snap.val() === true;
                console.log(isConnected ? '‚úÖ Connected to Firebase Database' : '‚ùå Not connected to Firebase Database');
            });
        }
        
        // Test Firebase connection
        const database = firebase.database();
        database.ref('.info/connected').on('value', (snap) => {
            if (snap.val() === true) {
                console.log('‚úÖ Connected to Firebase successfully');
            } else {
                console.log('‚ö†Ô∏è Not connected to Firebase');
            }
        });
    </script>
    
    <!-- Audio Elements with Multi-Format Support -->
    <audio id="bgMusic" loop preload="auto" volume="0.3">
        <source src="/assets/audio/background-music.mp3" type="audio/mpeg">
    </audio>

    <audio id="cardFlip" preload="auto" volume="0.7">
        <source src="/assets/audio/card-flip.wav" type="audio/wav">
    </audio>
    
    <audio id="cardPlace" preload="auto" volume="0.6">
        <source src="/assets/audio/card-place.wav" type="audio/wav">
    </audio>
    
    <audio id="peakCard" preload="auto" volume="0.8">
        <source src="/assets/audio/peak-card.m4a" type="audio/mp4">
    </audio>

    <audio id="goblinSound" preload="auto" volume="0.8">
        <source src="/assets/audio/goblin-sound.wav" type="audio/wav">
    </audio>

    <audio id="starSound" preload="auto" volume="0.8">
        <source src="/assets/audio/star-sound.wav" type="audio/wav">
    </audio>
    
    <audio id="winSound" preload="auto" volume="0.9">
        <source src="/assets/audio/win-sound.wav" type="audio/wav">
    </audio>
    
    <audio id="loseSound" preload="auto" volume="0.5">
        <source src="/assets/audio/lose-sound.mp3" type="audio/mpeg">
    </audio>

    <audio id="buttonClick" preload="auto" volume="0.4">
        <source src="/assets/audio/button-click.wav" type="audio/wav">
    </audio>
    
    <!-- Turn notification removed - file not available -->
    <!--<audio id="turnNotification" preload="auto" volume="0.6">
        <source src="audio/sfx/turn-notification.mp3" type="audio/mpeg">
        <source src="audio/sfx/turn-notification.wav" type="audio/wav">
        <source src="audio/sfx/turn-notification.ogg" type="audio/ogg">
    </audio>-->
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 25%, #f093fb 50%, #f5576c 75%, #4facfe 100%);
            background-size: 400% 400%;
            animation: gradientBg 15s ease infinite;
            min-height: 100vh;
            color: #333;
            font-size: 14px;
            padding-bottom: 50px;
        }
        
        @media (min-width: 480px) {
            body {
                font-size: 15px;
            }
        }
        
        @media (min-width: 768px) {
            body {
                font-size: 16px;
            }
        }

        @keyframes gradientBg {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        @keyframes playerTurnHighlight {
            0% { transform: scale(1); background-color: transparent; }
            50% { transform: scale(1.1); background-color: rgba(255, 255, 0, 0.2); }
            100% { transform: scale(1); background-color: transparent; }
        }
        
        .player-turn-highlight {
            animation: playerTurnHighlight 1s ease-in-out;
            border-radius: 4px;
            padding: 2px 6px;
        }
        
        .card-stack {
            transition: all 0.3s ease-in-out;
        }
        
        .card-stack .card {
            transition: all 0.3s ease-in-out;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        @keyframes lastPlayedHighlight {
            0% { transform: scale(1); box-shadow: 0 0 0 rgba(255, 215, 0, 0); }
            50% { transform: scale(1.05); box-shadow: 0 0 15px rgba(255, 215, 0, 0.5); }
            100% { transform: scale(1); box-shadow: 0 0 0 rgba(255, 215, 0, 0); }
        }
        
        .last-played-highlight {
            animation: lastPlayedHighlight 1s ease-in-out;
            z-index: 10 !important;
        }
        
        @keyframes directionChange {
            0% { transform: scale(1) rotate(0deg); opacity: 1; }
            50% { transform: scale(1.2) rotate(180deg); opacity: 0.7; }
            100% { transform: scale(1) rotate(360deg); opacity: 1; }
        }
        
        .direction-change {
            animation: directionChange 1s ease-in-out;
            display: inline-block;
        }

        /* Loading Spinner for Matchmaking */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin: 30px auto;
        }

        .game-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 5px;
        }
        
        /* Responsive Design - Mobile First */
        @media (min-width: 360px) {
            .game-container {
                padding: 8px;
            }
        }
        
        @media (min-width: 480px) {
            .game-container {
                padding: 12px;
            }
        }
        
        @media (min-width: 768px) {
            .game-container {
                padding: 20px;
            }
        }
        
        /* Landscape orientation for mobile devices */
        @media (max-height: 480px) and (orientation: landscape) {
            .game-container {
                padding: 5px;
            }
            
            .game-header {
                margin-bottom: 10px;
            }
            
            .title-container {
                margin-bottom: 10px;
                padding: 5px;
            }
            
            .peak-card {
                width: 40px;
                height: 60px;
                font-size: 1.5em;
            }
            
            .players-container {
                height: 250px;
                min-height: 250px;
            }
        }
        
        /* Touch-friendly improvements */
        @media (pointer: coarse) {
            .btn {
                min-height: 44px;
                padding: 12px 20px;
            }
            
            .player-count-btn {
                min-height: 60px;
                padding: 15px 12px;
            }
            
            .card:hover {
                transform: scale(1.1);
            }
        }
        
        /* Audio Controls Styles */
        .audio-controls-main {
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            padding: 15px;
            margin: 15px 0;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            backdrop-filter: blur(10px);
            flex-wrap: wrap;
        }
        
        @media (max-width: 480px) {
            .audio-controls-main {
                flex-direction: column;
                gap: 10px;
            }
        }
        
        .audio-btn {
            background: linear-gradient(145deg, #55efc4, #00b894);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: bold;
            transition: all 0.3s ease;
            min-width: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }
        
        .audio-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(85, 239, 196, 0.4);
        }
        
        .audio-btn:active {
            transform: translateY(0);
        }
        
        .audio-btn.muted {
            background: linear-gradient(145deg, #e74c3c, #c0392b);
        }
        
        .volume-control {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(255,255,255,0.7);
            border-radius: 15px;
            border: 2px solid #ddd;
        }
        
        .volume-control span {
            font-size: 1.2em;
            color: #333;
        }
        
        #volumeSlider {
            width: 100px;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }
        
        @media (max-width: 480px) {
            #volumeSlider {
                width: 120px;
            }
        }
        
        #volumeSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #55efc4;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }
        
        #volumeSlider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #55efc4;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        .game-header {
            text-align: center;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }
        
        @media (min-width: 768px) {
            .game-header {
                margin-bottom: 40px;
            }
        }

        /* Clean Title Container */
        .title-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
            padding: 10px;
            flex-wrap: wrap;
        }
        
        .modal-title {
            transform: scale(0.6);
            margin: -25px auto -30px auto; /* Increased negative bottom margin to pull content up */
            flex-direction: column;
            padding: 0;
        }
        
        .modal-title .peak-cards {
            margin-bottom: 2px;
            transform: scale(0.9);
        }
        
        .modal-title .subtitle {
            margin-top: 2px;
            font-size: 1em;
            margin-bottom: -10px; /* Pull up the content below */
        }
        
        @media (min-width: 768px) {
            .title-container {
                margin-bottom: 40px;
                padding: 20px;
                flex-wrap: nowrap;
            }
        }

        /* PEAK Cards Layout */
        .peak-cards {
            display: flex;
            gap: 8px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }
        
        @media (min-width: 480px) {
            .peak-cards {
                gap: 12px;
            }
        }
        
        @media (min-width: 768px) {
            .peak-cards {
                gap: 15px;
                flex-wrap: nowrap;
            }
        }

        .peak-card {
            width: 60px;
            height: 90px;
            background: linear-gradient(145deg, #ffffff, #f8f9fa);
            border: 2px solid #333;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            font-weight: 900;
            color: #333;
            box-shadow: 
                0 4px 8px rgba(0,0,0,0.2),
                inset 0 1px 0 rgba(255,255,255,0.8);
            animation: cardFloat 3s ease-in-out infinite;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        @media (min-width: 480px) {
            .peak-card {
                width: 80px;
                height: 120px;
                font-size: 2.5em;
                border-radius: 10px;
            }
        }
        
        @media (min-width: 768px) {
            .peak-card {
                width: 100px;
                height: 150px;
                font-size: 3.5em;
                border: 3px solid #333;
                border-radius: 12px;
                box-shadow: 
                    0 6px 12px rgba(0,0,0,0.2),
                    inset 0 1px 0 rgba(255,255,255,0.8);
            }
        }
        
        @media (min-width: 1024px) {
            .peak-card {
                width: 120px;
                height: 180px;
                font-size: 4em;
                border-radius: 15px;
                box-shadow: 
                    0 8px 16px rgba(0,0,0,0.2),
                    inset 0 1px 0 rgba(255,255,255,0.8);
            }
        }

        .peak-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.4), transparent);
            transform: rotate(45deg);
            animation: cardShimmer 4s linear infinite;
        }

        .peak-card:hover {
            transform: translateY(-10px) scale(1.05);
            box-shadow: 
                0 15px 25px rgba(0,0,0,0.3),
                inset 0 1px 0 rgba(255,255,255,0.9);
        }

        .peak-card:nth-child(1) { 
            animation-delay: 0s; 
            background: linear-gradient(145deg, #ff9a9e, #fecfef, #ffffff);
        }
        .peak-card:nth-child(2) { 
            animation-delay: 0.5s; 
            background: linear-gradient(145deg, #a8edea, #fed6e3, #ffffff);
        }
        .peak-card:nth-child(3) { 
            animation-delay: 1s; 
            background: linear-gradient(145deg, #fbc2eb, #a6c1ee, #ffffff);
        }
        .peak-card:nth-child(4) { 
            animation-delay: 1.5s; 
            background: linear-gradient(145deg, #c2e9fb, #a1c4fd, #ffffff);
        }

        @keyframes cardFloat {
            0%, 100% { 
                transform: translateY(0) rotate(0deg);
            }
            50% { 
                transform: translateY(-15px) rotate(1deg);
            }
        }

        @keyframes cardShimmer {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
        }

        /* Subtitle styling */
        .subtitle {
            font-size: 0.9em;
            font-weight: 300;
            color: #666;
            text-align: center;
            margin-top: 10px;
            letter-spacing: 2px;
            text-transform: uppercase;
            opacity: 0.8;
        }

        .game-info {
            background: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(168, 230, 207, 0.9), rgba(220, 237, 200, 0.9));
            padding: 20px;
            border-radius: 20px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 
                0 8px 16px rgba(0,0,0,0.1),
                0 0 30px rgba(85, 239, 196, 0.2),
                inset 0 1px 0 rgba(255,255,255,0.6);
            border: 2px solid rgba(85, 239, 196, 0.3);
        }

        /* Floating game messages overlay: keep messages above all table elements */
        #gameMessages {
            position: fixed;
            top: 110px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 99999;
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: none; /* allow clicks through unless child enables pointer events */
            width: auto;
            max-width: 90%;
            align-items: center;
        }

        .game-message {
            pointer-events: auto; /* allow interaction with message (if needed) */
            min-width: 180px;
            max-width: 90%;
            text-align: center;
            border-radius: 8px;
            padding: 8px 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.25);
            font-size: 0.9em;
        }
        
        @media (min-width: 480px) {
            .game-message {
                min-width: 220px;
                max-width: 500px;
                border-radius: 9px;
                padding: 9px 13px;
                font-size: 1em;
            }
        }
        
        @media (min-width: 768px) {
            .game-message {
                max-width: 640px;
                border-radius: 10px;
                padding: 10px 14px;
                box-shadow: 0 6px 18px rgba(0,0,0,0.25);
            }
        }

        .info-item {
            text-align: center;
        }

        .info-label {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 1.3em;
            font-weight: bold;
            background: linear-gradient(45deg, #6c5ce7, #a29bfe, #fd79a8);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        .game-table {
            position: relative;
            width: 400px;
            height: 400px;
            margin: 0 auto 30px;
            background: radial-gradient(circle, #00b894 0%, #00a085 30%, #2d5016 60%, #1a3009 100%);
            border-radius: 50%;
            border: 12px solid #fdcb6e;
            box-shadow: 
                0 0 30px rgba(253, 203, 110, 0.6),
                0 0 50px rgba(0, 184, 148, 0.4),
                inset 0 0 40px rgba(0,0,0,0.2),
                inset 0 0 80px rgba(253, 203, 110, 0.1);
            animation: tableGlow 4s ease-in-out infinite alternate;
        }

        @keyframes tableGlow {
            0% {
                box-shadow: 
                    0 0 30px rgba(253, 203, 110, 0.6),
                    0 0 50px rgba(0, 184, 148, 0.4),
                    inset 0 0 40px rgba(0,0,0,0.2);
            }
            100% {
                box-shadow: 
                    0 0 50px rgba(253, 203, 110, 0.8),
                    0 0 70px rgba(0, 184, 148, 0.6),
                    inset 0 0 60px rgba(0,0,0,0.1);
            }
        }

        .game-table::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 120px;
            height: 120px;
            background: radial-gradient(circle, #ff9ff3 0%, #a29bfe 50%, #6c5ce7 100%);
            border-radius: 50%;
            border: 3px solid rgba(253, 203, 110, 0.8);
            animation: centerPulse 3s ease-in-out infinite alternate;
        }

        @keyframes centerPulse {
            0% {
                transform: translate(-50%, -50%) scale(1);
                box-shadow: 0 0 20px rgba(255, 159, 243, 0.5);
            }
            100% {
                transform: translate(-50%, -50%) scale(1.05);
                box-shadow: 0 0 30px rgba(255, 159, 243, 0.8);
            }
        }

        .players-container {
            position: relative;
            width: 100%;
            height: 300px;
            min-height: 300px;
        }
        
        @media (min-width: 768px) {
            .players-container {
                height: 100%;
                min-height: 400px;
            }
        }

        .player-seat {
            position: absolute;
            width: 100px;
            transform-origin: center;
        }
        
        @media (min-width: 480px) {
            .player-seat {
                width: 120px;
            }
        }
        
        @media (min-width: 768px) {
            .player-seat {
                width: 140px;
            }
        }

        .player-seat:nth-child(1) {
            top: -70px;
            left: 50%;
            transform: translateX(-50%);
        }

        .player-seat:nth-child(2) {
            top: 50%;
            right: -70px;
            transform: translateY(-50%);
        }

        .player-seat:nth-child(3) {
            bottom: -70px;
            left: 50%;
            transform: translateX(-50%);
        }

        .player-seat:nth-child(4) {
            top: 50%;
            left: -70px;
            transform: translateY(-50%);
        }

        .player-avatar {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(255,255,255,0.95);
            border-radius: 10px;
            padding: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }
        
        @media (min-width: 480px) {
            .player-avatar {
                border-radius: 12px;
                padding: 9px;
            }
        }
        
        @media (min-width: 768px) {
            .player-avatar {
                border-radius: 15px;
                padding: 10px;
                box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            }
        }

        .player-avatar.current-turn {
            border: 2px solid #4CAF50;
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.6);
            transform: scale(1.02);
            background: rgba(76, 175, 80, 0.1);
        }

        .player-avatar.disqualified {
            opacity: 0.6;
            border: 2px solid #f44336;
            background: rgba(244, 67, 54, 0.1);
        }

        .player-avatar.finished {
            border: 2px solid #FFD700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
            background: rgba(255, 215, 0, 0.1);
        }

        .avatar-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3em;
            margin-bottom: 5px;
            border: 2px solid #333;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .avatar-icon {
            position: relative;
            animation: avatarPulse 2s ease-in-out infinite;
        }

        @keyframes avatarPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .avatar-icon:nth-child(1) { 
            background: linear-gradient(135deg, #ff6b6b, #ee5a24, #fd79a8);
            box-shadow: 0 0 15px rgba(255, 107, 107, 0.6);
        }
        .avatar-icon:nth-child(2) { 
            background: linear-gradient(135deg, #4ecdc4, #00b894, #55efc4);
            box-shadow: 0 0 15px rgba(78, 205, 196, 0.6);
        }
        .avatar-icon:nth-child(3) { 
            background: linear-gradient(135deg, #a29bfe, #6c5ce7, #fd79a8);
            box-shadow: 0 0 15px rgba(162, 155, 254, 0.6);
        }
        .avatar-icon:nth-child(4) { 
            background: linear-gradient(135deg, #fdcb6e, #e17055, #fab1a0);
            box-shadow: 0 0 15px rgba(253, 203, 110, 0.6);
        }

        .avatar-icon::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5em;
            z-index: 1;
        }

        .player-seat:nth-child(1) .avatar-icon::after { content: 'ü¶Ñ'; }
        .player-seat:nth-child(2) .avatar-icon::after { content: 'üêâ'; }
        .player-seat:nth-child(3) .avatar-icon::after { content: 'ü¶∏‚Äç‚ôÄÔ∏è'; }
        .player-seat:nth-child(4) .avatar-icon::after { content: 'üé≠'; }

        .player-name {
            font-size: 0.9em;
            font-weight: bold;
            margin-bottom: 3px;
            text-align: center;
            color: #333;
        }

        .player-status {
            font-size: 0.8em;
            padding: 4px 8px;
            border-radius: 12px;
            color: white;
        }

        .status-active { background: #4CAF50; }
        .status-disqualified { background: #f44336; }
        .status-finished { background: #FFD700; color: #333; }

        .player-hand {
            display: flex;
            flex-wrap: wrap;
            gap: 2px;
            margin-top: 5px;
            justify-content: center;
            max-width: 120px;
            max-height: 150px;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 3px;
        }
        
        /* Custom scrollbar styling for player hands */
        .player-hand::-webkit-scrollbar {
            width: 4px;
        }
        
        .player-hand::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 2px;
        }
        
        .player-hand::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 2px;
        }
        
        .player-hand::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.3);
        }
        
        /* Expand player hand on larger screens */
        @media (min-width: 480px) {
            .player-hand {
                max-width: 160px;
                max-height: 180px;
            }
        }
        
        @media (min-width: 768px) {
            .player-hand {
                max-width: 200px;
                max-height: 200px;
            }
        }
        
        @media (min-width: 1024px) {
            .player-hand {
                max-width: 250px;
                max-height: 220px;
            }
        }
        
        /* Special styling for own hand - allow more space */
        .player-hand.own-hand {
            max-width: 100%;
            max-height: 140px;
        }
        
        @media (min-width: 480px) {
            .player-hand.own-hand {
                max-height: 160px;
            }
        }
        
        @media (min-width: 768px) {
            .player-hand.own-hand {
                max-height: 180px;
            }
        }

        .player-seat .card {
            width: 22px;
            height: 32px;
            font-size: 0.6em;
        }

        .card-count {
            font-size: 0.8em;
            color: #666;
            text-align: center;
            margin-bottom: 3px;
        }

        .card {
            width: 55px;
            height: 75px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            box-shadow: 
                0 2px 4px rgba(0,0,0,0.2),
                0 0 0 1px rgba(255,255,255,0.3) inset,
                0 0 15px rgba(255,255,255,0.1) inset;
            position: relative;
            overflow: hidden;
        }
        
        @media (min-width: 480px) {
            .card {
                width: 65px;
                height: 90px;
                border-radius: 10px;
                font-size: 1em;
            }
        }
        
        @media (min-width: 768px) {
            .card {
                width: 75px;
                height: 105px;
                border-radius: 12px;
                font-size: 1.1em;
                border: 3px solid transparent;
                box-shadow: 
                    0 4px 8px rgba(0,0,0,0.2),
                    0 0 0 1px rgba(255,255,255,0.3) inset,
                    0 0 20px rgba(255,255,255,0.1) inset;
            }
        }

        @media (min-width: 1024px) {
            .card {
                width: 85px;
                height: 120px;
                border-radius: 14px;
                font-size: 1.2em;
            }
        }

        @keyframes cardGlow {
            0%, 100% { box-shadow: 0 4px 8px rgba(0,0,0,0.2), 0 0 15px rgba(255,255,255,0.1); }
            50% { box-shadow: 0 6px 12px rgba(0,0,0,0.3), 0 0 25px rgba(255,255,255,0.2); }
        }

        .card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.2), transparent);
            transform: rotate(45deg);
            animation: cardShimmer 3s linear infinite;
        }

        @keyframes cardShimmer {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
        }

        .card:hover {
            transform: translateY(-8px) scale(1.05);
            box-shadow: 
                0 8px 16px rgba(0,0,0,0.3),
                0 0 30px rgba(255,255,255,0.3);
            border-color: #fff;
        }

        .card.regular {
            background: linear-gradient(145deg, #a8e6cf, #dcedc8, #f8f9fa);
            color: #2d3436;
            border: 3px solid #00b894;
            position: relative;
        }

        .card.regular::after {
            content: '‚≠ê';
            position: absolute;
            top: 3px;
            right: 5px;
            font-size: 0.7em;
            opacity: 0.8;
        }

        .card.peak {
            background: linear-gradient(145deg, #ff6b6b, #ee5a24, #fd79a8);
            color: white;
            font-size: 0.6em;
            border: 3px solid #d63031;
            animation: peakPulse 1.5s ease-in-out infinite;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 3px;
            padding: 4px;
        }

        .card.peak::before {
            content: '+5';
            position: absolute;
            top: 3px;
            right: 3px;
            font-size: 1.2em;
            font-weight: bold;
            background: rgba(0,0,0,0.5);
            padding: 2px 6px;
            border-radius: 4px;
            color: #ffff00;
            border: 1px solid #ffff00;
        }

        .card.peak::after {
            content: 'üòÇ';
            position: absolute;
            bottom: 3px;
            left: 3px;
            font-size: 1.2em;
        }

        @keyframes peakPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 107, 107, 0.5); }
            50% { box-shadow: 0 0 25px rgba(255, 107, 107, 0.8); }
        }

        .card.reverse {
            background: linear-gradient(145deg, #a29bfe, #6c5ce7, #fd79a8);
            color: white;
            font-size: 0.6em;
            position: relative;
            border: 3px solid #5f3dc4;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 3px;
            padding: 4px;
            animation: reverseRotate 2s linear infinite;
        }

        @keyframes reverseRotate {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(180deg); }
        }

        .card.reverse:before {
            content: '‚Ü©Ô∏èREVERSE';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.9em;
            animation: inheritRotate 2s linear infinite;
        }

        @keyframes inheritRotate {
            0%, 100% { transform: translate(-50%, -50%) rotate(0deg); }
            50% { transform: translate(-50%, -50%) rotate(180deg); }
        }

        .card.star {
            background: linear-gradient(145deg, #55efc4, #00b894, #a8e6cf);
            color: white;
            font-size: 0.6em;
            position: relative;
            border: 3px solid #00a085;
            animation: starTwinkle 1s ease-in-out infinite alternate;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 3px;
            padding: 4px;
        }

        @keyframes starTwinkle {
            0% { box-shadow: 0 0 10px rgba(85, 239, 196, 0.5); }
            100% { box-shadow: 0 0 30px rgba(85, 239, 196, 0.9); }
        }

        .card.star:before {
            content: '‚≠ê‚≠ê‚≠ê';
            position: absolute;
            top: 2px;
            font-size: 0.9em;
            animation: starSpin 3s ease-in-out infinite;
            letter-spacing: 2px;
        }

        .card.star:after {
            content: '-Peak';
            position: absolute;
            bottom: 3px;
            right: 3px;
            font-size: 1em;
            font-weight: bold;
            background: rgba(0,0,0,0.5);
            padding: 2px 6px;
            border-radius: 4px;
            color: #ff0000;
            border: 1px solid #ff0000;
        }

        .card.goblin {
            background: linear-gradient(145deg, #fd79a8, #e84393, #a29bfe);
            color: white;
            font-size: 0.6em;
            position: relative;
            border: 3px solid #e84393;
            animation: goblinBounce 0.8s ease-in-out infinite alternate;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 3px;
            padding: 4px;
        }

        @keyframes goblinBounce {
            0% { transform: scale(1); }
            100% { transform: scale(1.1); }
        }

        .card.goblin:before {
            content: 'üëπ';
            position: absolute;
            top: 2px;
            font-size: 1.3em;
            animation: goblinShake 0.5s ease-in-out infinite alternate;
        }

        .card.goblin:after {
            content: '+1';
            position: absolute;
            bottom: 3px;
            right: 3px;
            font-size: 1.2em;
            font-weight: bold;
            background: rgba(0,0,0,0.5);
            padding: 2px 6px;
            border-radius: 4px;
            color: #ffff00;
            border: 1px solid #ffff00;
            animation: none;
        }

        .card.pause {
            background: linear-gradient(145deg, #fdcb6e, #e17055, #fab1a0);
            color: white;
            font-size: 0.6em;
            position: relative;
            border: 3px solid #e17055;
            animation: pausePulse 2s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 3px;
            padding: 4px;
        }

        @keyframes pausePulse {
            0%, 100% { opacity: 1; box-shadow: 0 0 10px rgba(225, 112, 85, 0.5); }
            50% { opacity: 0.7; box-shadow: 0 0 20px rgba(225, 112, 85, 0.8); }
        }

        .card.pause:before {
            content: '‚è∏Ô∏èPAUSE';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.9em;
        }

        .card.pause:after {
            content: 'RARE';
            position: absolute;
            bottom: 3px;
            right: 3px;
            font-size: 0.8em;
            font-weight: bold;
            background: rgba(255,215,0,0.7);
            color: #ff6b00;
            padding: 2px 5px;
            border-radius: 3px;
        }

        .card.card-back {
            background: linear-gradient(145deg, #2c2c2c, #1a1a1a) !important;
            color: #666 !important;
            border: 2px solid #444;
            cursor: default !important;
        }

        .card.card-back:hover {
            transform: none !important;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2) !important;
        }

        .card.playable {
            border-color: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        .card.last-played {
            border-color: #2196F3;
            box-shadow: 0 0 15px rgba(33, 150, 243, 0.6);
            transform: scale(1.1);
        }

        .table-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 10;
        }

        .discard-pile-center {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .discard-label {
            color: #fff;
            font-size: 1em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            font-weight: bold;
            background: rgba(0,0,0,0.3);
            padding: 5px 10px;
            border-radius: 15px;
            backdrop-filter: blur(5px);
        }

        .controls {
            background: rgba(255,255,255,0.95);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }
        
        @media (min-width: 768px) {
            .controls {
                padding: 20px;
                border-radius: 15px;
                flex-direction: row;
                justify-content: center;
                gap: 0;
            }
        }

        .btn {
            background: linear-gradient(145deg, #55efc4, #00b894, #4CAF50);
            color: white;
            border: none;
            padding: 12px 20px;
            margin: 5px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 
                0 2px 6px rgba(0,0,0,0.2),
                0 0 15px rgba(85, 239, 196, 0.3);
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1px;
            width: 100%;
            max-width: 200px;
        }
        
        @media (min-width: 480px) {
            .btn {
                padding: 14px 25px;
                margin: 6px;
                font-size: 1em;
                max-width: 250px;
            }
        }
        
        @media (min-width: 768px) {
            .btn {
                padding: 15px 30px;
                margin: 8px;
                border-radius: 25px;
                font-size: 1.1em;
                box-shadow: 
                    0 4px 8px rgba(0,0,0,0.2),
                    0 0 20px rgba(85, 239, 196, 0.3);
                width: auto;
                max-width: none;
            }
        }

        .btn::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.3), transparent);
            transform: rotate(45deg);
            transition: all 0.3s ease;
            opacity: 0;
        }

        .btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 
                0 8px 16px rgba(0,0,0,0.3),
                0 0 30px rgba(85, 239, 196, 0.6);
        }

        .btn:hover::before {
            opacity: 1;
            animation: buttonShimmer 0.6s ease-in-out;
        }

        @keyframes buttonShimmer {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn.draw { 
            background: linear-gradient(145deg, #74b9ff, #0984e3, #2196F3);
            box-shadow: 
                0 4px 8px rgba(0,0,0,0.2),
                0 0 20px rgba(116, 185, 255, 0.4);
        }
        
        .btn.draw:hover {
            box-shadow: 
                0 8px 16px rgba(0,0,0,0.3),
                0 0 30px rgba(116, 185, 255, 0.7);
        }
        
        .btn.quit { 
            background: linear-gradient(145deg, #fd79a8, #e84393, #f44336);
            box-shadow: 
                0 4px 8px rgba(0,0,0,0.2),
                0 0 20px rgba(253, 121, 168, 0.4);
        }
        
        .btn.quit:hover {
            box-shadow: 
                0 8px 16px rgba(0,0,0,0.3),
                0 0 30px rgba(253, 121, 168, 0.7);
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
        }

        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            width: 90%;
            max-width: 500px;
            min-width: 320px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        /* Ensure modal displays properly on desktop */
        @media (min-width: 768px) {
            .modal-content {
                width: 80%;
                max-width: 600px;
                min-width: 500px;
            }
        }

        @media (min-width: 1024px) {
            .modal-content {
                width: 70%;
                max-width: 700px;
                min-width: 600px;
            }
        }

        /* Settings Gear Button */
        .settings-gear {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255,255,255,0.9);
            border: 2px solid #ddd;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 1.5em;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .settings-gear:hover {
            background: #fff;
            border-color: #55efc4;
            transform: rotate(90deg) scale(1.1);
            box-shadow: 0 4px 12px rgba(85, 239, 196, 0.3);
        }

        /* Settings Modal Specific Styles */
        #settingsModal .modal-content {
            text-align: left;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f0f0f0;
        }

        .modal-header h2 {
            margin: 0;
            color: #333;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            color: #999;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .close-btn:hover {
            background: #f0f0f0;
            color: #333;
        }

        .settings-section {
            margin-bottom: 25px;
        }

        .settings-section h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            border-bottom: 1px solid #f0f0f0;
            min-height: 50px;
        }

        .setting-item:last-child {
            border-bottom: none;
        }

        .setting-item label {
            font-weight: 500;
            color: #333;
            font-size: 1em;
            flex: 1;
        }

        /* Toggle Switch */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
            cursor: pointer;
        }

        .toggle-switch input {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
            z-index: 2;
            margin: 0;
            padding: 0;
        }

        .slider {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 24px;
            pointer-events: none;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #55efc4;
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        /* Volume Slider in Settings */
        .volume-slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
            min-width: 200px;
        }

        #volumeSliderModal {
            width: 150px;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        #volumeSliderModal::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #55efc4;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        #volumeSliderModal::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #55efc4;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        #volumePercent {
            min-width: 45px;
            font-weight: bold;
            color: #55efc4;
            font-size: 1em;
        }

        .game-credits {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .game-credits p {
            margin: 5px 0;
            color: #666;
        }

        .game-credits p:first-child {
            font-weight: bold;
            color: #333;
            font-size: 1.1em;
        }

        /* Audio Status Styles - HIDDEN */
        #audioStatus,
        .audio-status {
            display: none !important;
        }
        
        /* Hide the entire audio status section */
        .settings-section:has(#audioStatus) {
            display: none !important;
        }

        .audio-status .loading {
            color: #666;
            text-align: center;
        }

        .audio-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
            padding: 5px 0;
        }

        .audio-item.ready {
            color: #27ae60;
        }

        .audio-item.not-ready {
            color: #e74c3c;
        }

        .audio-item .status {
            font-weight: bold;
        }

        .test-audio-btn {
            width: 100%;
            margin-top: 10px;
            background: linear-gradient(145deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95em;
            transition: all 0.3s ease;
        }

        .test-audio-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        .modal-footer {
            margin-top: 20px;
            text-align: center;
            padding-top: 15px;
            border-top: 2px solid #f0f0f0;
        }

        /* Desktop Settings Enhancement */
        @media (min-width: 768px) {
            .settings-section {
                margin-bottom: 30px;
            }
            
            .setting-item {
                padding: 18px 0;
            }
            
            .toggle-switch {
                width: 60px;
                height: 30px;
            }
            
            .slider:before {
                height: 22px;
                width: 22px;
                left: 4px;
                bottom: 4px;
            }
            
            input:checked + .slider:before {
                transform: translateX(30px);
            }
        }

        /* Responsive Settings Modal */
        @media (max-width: 767px) {
            .modal-content {
                min-width: 300px;
                max-width: 95%;
                padding: 20px;
                margin: 5% auto;
            }
            
            .settings-gear {
                width: 35px;
                height: 35px;
                font-size: 1.2em;
            }
            
            .setting-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
                padding: 15px 0;
            }
            
            .setting-item label {
                margin-bottom: 5px;
            }
            
            .volume-slider-container {
                width: 100%;
                justify-content: space-between;
                min-width: auto;
            }
            
            #volumeSliderModal {
                flex: 1;
                margin: 0 15px;
                width: auto;
            }
        }

        .setup-form {
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 15px;
            max-width: 400px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        
        @media (min-width: 768px) {
            .setup-form {
                gap: 15px;
                padding: 20px;
            }
        }

        .player-input {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 1em;
            width: 100%;
        }
        
        @media (min-width: 768px) {
            .player-input {
                padding: 12px;
                border-radius: 8px;
            }
        }

        .player-input:focus {
            border-color: #4CAF50;
            outline: none;
        }

        .game-message {
            background: rgba(255,255,255,0.9);
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            text-align: center;
            font-weight: bold;
        }

        .message-info { border-left: 4px solid #2196F3; }
        .message-success { border-left: 4px solid #4CAF50; }
        .message-warning { border-left: 4px solid #ff9800; }
        .message-error { border-left: 4px solid #f44336; }

        .rules-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.9);
            border: none;
            padding: 10px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 1em;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .rules-panel {
            display: none;
            position: fixed;
            top: 70px;
            right: 20px;
            background: white;
            padding: 20px;
            border-radius: 15px;
            max-width: 300px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            z-index: 100;
        }

        .rules-panel h3 {
            color: #4CAF50;
            margin-bottom: 10px;
        }

        .rules-panel ul {
            list-style-type: none;
            padding-left: 0;
        }

        .rules-panel li {
            padding: 5px 0;
            border-bottom: 1px solid #eee;
        }

        @media (max-width: 768px) {
            .game-table {
                width: 380px;
                height: 380px;
            }
            
            .player-seat {
                width: 110px;
            }
            
            .player-seat:nth-child(1) { top: -60px; }
            .player-seat:nth-child(2) { right: -60px; }
            .player-seat:nth-child(3) { bottom: -60px; }
            .player-seat:nth-child(4) { left: -60px; }
            
            .avatar-icon {
                width: 32px;
                height: 32px;
                font-size: 1.1em;
            }
            
            .player-seat .card {
                width: 18px;
                height: 26px;
                font-size: 0.5em;
            }
            
            .player-avatar {
                padding: 8px;
                max-width: 100px;
            }
            
            .game-info {
                flex-direction: column;
                gap: 15px;
            }
            
            .game-title {
                font-size: 3.5em;
            }
            
            .title-card {
                width: 60px;
                height: 90px;
                font-size: 1.2em;
            }
        }



        /* Player Count Selection Styles */
        .player-count-options {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            padding: 0 10px;
            position: relative;
            z-index: 1;
        }
        
        @media (min-width: 768px) {
            .player-count-options {
                gap: 15px;
                padding: 0;
            }
        }

        .player-count-btn {
            background: linear-gradient(145deg, rgba(255,255,255,0.9), rgba(168, 230, 207, 0.8));
            border: 2px solid #ddd;
            border-radius: 15px;
            padding: 15px 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 100px;
            flex: 1;
            max-width: 120px;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 10;
            pointer-events: auto;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        @media (min-width: 480px) {
            .player-count-btn {
                padding: 17px 12px;
                min-width: 120px;
                max-width: 140px;
                border-radius: 17px;
            }
        }
        
        @media (min-width: 768px) {
            .player-count-btn {
                border: 3px solid #ddd;
                border-radius: 20px;
                padding: 20px 15px;
                min-width: 140px;
                flex: none;
                max-width: none;
            }
        }

        .player-count-btn:hover {
            transform: translateY(-3px) scale(1.05);
            border-color: #55efc4;
            box-shadow: 0 8px 20px rgba(85, 239, 196, 0.4);
        }

        .player-count-btn.selected {
            background: linear-gradient(145deg, #55efc4, #00b894);
            border-color: #00a085;
            color: white;
            transform: scale(1.1);
            box-shadow: 0 0 25px rgba(85, 239, 196, 0.6);
        }

        .player-count-btn::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.2), transparent);
            transform: rotate(45deg);
            transition: all 0.3s ease;
            opacity: 0;
            z-index: -1;
            pointer-events: none;
        }

        .player-count-btn:hover::before {
            opacity: 1;
            animation: buttonShimmer 0.6s ease-in-out;
        }

        .count-emoji {
            font-size: 2em;
            margin-bottom: 5px;
            pointer-events: none;
            user-select: none;
        }

        .count-text {
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 2px;
            pointer-events: none;
            user-select: none;
        }

        .count-desc {
            font-size: 0.8em;
            opacity: 0.8;
            text-align: center;
            line-height: 1.2;
            pointer-events: none;
            user-select: none;
        }

        .player-count-btn.selected .count-desc {
            opacity: 0.9;
        }

        #playerCountSection {
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            padding: 20px;
            border: 2px solid rgba(85, 239, 196, 0.2);
        }

        #playerCountSection p {
            color: #333;
            font-weight: bold;
            text-align: center;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        /* Special Card Animation Overlays */
        .special-card-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Peak Card Animation - Mountain avalanche effect */
        .peak-animation {
            animation: peakEffect 2s ease-out forwards;
        }

        @keyframes peakEffect {
            0% {
                background: radial-gradient(circle, transparent 0%, rgba(255, 107, 107, 0) 50%);
            }
            25% {
                background: radial-gradient(circle, rgba(255, 107, 107, 0.3) 0%, rgba(255, 107, 107, 0.1) 50%, transparent 70%);
            }
            50% {
                background: radial-gradient(circle, rgba(255, 107, 107, 0.5) 0%, rgba(255, 107, 107, 0.2) 50%, transparent 70%);
            }
            100% {
                background: radial-gradient(circle, transparent 0%, transparent 50%);
                opacity: 0;
            }
        }

        .peak-text {
            font-size: 6em;
            font-weight: 900;
            color: #ff6b6b;
            text-shadow: 
                4px 4px 0px #ee5a24,
                8px 8px 0px #d63031,
                12px 12px 20px rgba(0,0,0,0.5);
            animation: peakTextBounce 2s ease-out forwards;
            letter-spacing: 0.2em;
            font-family: 'Arial', sans-serif;
        }

        @keyframes peakTextBounce {
            0% { 
                transform: scale(0) rotate(-10deg); 
                opacity: 0; 
            }
            30% { 
                transform: scale(1.3) rotate(2deg); 
                opacity: 1; 
            }
            50% { 
                transform: scale(1.1) rotate(-1deg); 
                opacity: 1; 
            }
            70% { 
                transform: scale(1.2) rotate(1deg); 
                opacity: 1; 
            }
            90% { 
                transform: scale(1.05) rotate(0deg); 
                opacity: 0.8; 
            }
            100% { 
                transform: scale(0) rotate(0deg); 
                opacity: 0; 
            }
        }

        /* Reverse Card Animation - Spinning effect */
        .reverse-animation {
            animation: reverseEffect 2s ease-out forwards;
            background: radial-gradient(circle, rgba(162, 155, 254, 0.2) 0%, transparent 60%);
        }

        @keyframes reverseEffect {
            0% { transform: rotate(0deg); opacity: 1; }
            100% { transform: rotate(720deg); opacity: 0; }
        }

        .reverse-emoji {
            font-size: 6em;
            animation: reverseSpiral 2s ease-out forwards;
            filter: drop-shadow(0 0 20px rgba(162, 155, 254, 0.8));
        }

        @keyframes reverseSpiral {
            0% { 
                transform: scale(0) rotate(0deg); 
                opacity: 0; 
            }
            20% { 
                transform: scale(1.5) rotate(180deg); 
                opacity: 1; 
            }
            40% { 
                transform: scale(1) rotate(360deg); 
                opacity: 1; 
            }
            60% { 
                transform: scale(1.2) rotate(540deg); 
                opacity: 1; 
            }
            80% { 
                transform: scale(0.8) rotate(720deg); 
                opacity: 0.8; 
            }
            100% { 
                transform: scale(0) rotate(900deg); 
                opacity: 0; 
            }
        }

        /* Star Card Animation - Sparkle explosion */
        .star-animation {
            animation: starEffect 2.5s ease-out forwards;
        }

        .star-emoji {
            font-size: 7em;
            animation: starExplode 2.5s ease-out forwards;
            filter: drop-shadow(0 0 30px rgba(85, 239, 196, 0.9));
        }

        @keyframes starExplode {
            0% { 
                transform: scale(0) rotate(0deg); 
                opacity: 0; 
            }
            30% { 
                transform: scale(1.8) rotate(180deg); 
                opacity: 1; 
            }
            70% { 
                transform: scale(1.2) rotate(360deg); 
                opacity: 1; 
            }
            100% { 
                transform: scale(0) rotate(540deg); 
                opacity: 0; 
            }
        }

        .sparkle-particle {
            position: absolute;
            font-size: 2em;
            animation: sparkleParticle 2s ease-out forwards;
        }

        @keyframes sparkleParticle {
            0% { 
                transform: scale(0); 
                opacity: 1; 
            }
            50% { 
                transform: scale(1); 
                opacity: 1; 
            }
            100% { 
                transform: scale(0.5); 
                opacity: 0; 
            }
        }

        /* Goblin Card Animation - Chaotic bounce */
        .goblin-animation {
            animation: goblinEffect 2s ease-out forwards;
            background: radial-gradient(circle, rgba(253, 121, 168, 0.2) 0%, transparent 60%);
        }

        .goblin-emoji {
            font-size: 8em;
            animation: goblinChaos 2s ease-out forwards;
            filter: drop-shadow(0 0 25px rgba(253, 121, 168, 0.8));
        }

        @keyframes goblinChaos {
            0% { 
                transform: scale(0) rotate(0deg); 
                opacity: 0; 
            }
            15% { 
                transform: scale(1.3) rotate(45deg) translateX(20px); 
                opacity: 1; 
            }
            30% { 
                transform: scale(0.9) rotate(-30deg) translateX(-15px); 
                opacity: 1; 
            }
            45% { 
                transform: scale(1.2) rotate(60deg) translateY(-10px); 
                opacity: 1; 
            }
            60% { 
                transform: scale(1) rotate(-45deg) translateY(10px); 
                opacity: 1; 
            }
            80% { 
                transform: scale(1.1) rotate(0deg); 
                opacity: 0.8; 
            }
            100% { 
                transform: scale(0) rotate(0deg); 
                opacity: 0; 
            }
        }

        /* Pause Card Animation - Clock effect */
        .pause-animation {
            animation: pauseEffect 2s ease-out forwards;
            background: radial-gradient(circle, rgba(253, 203, 110, 0.2) 0%, transparent 60%);
        }

        .pause-emoji {
            font-size: 7em;
            animation: pauseClock 2s ease-out forwards;
            filter: drop-shadow(0 0 20px rgba(253, 203, 110, 0.8));
        }

        @keyframes pauseClock {
            0% { 
                transform: scale(0) rotate(0deg); 
                opacity: 0; 
            }
            25% { 
                transform: scale(1.5) rotate(90deg); 
                opacity: 1; 
            }
            50% { 
                transform: scale(1.2) rotate(180deg); 
                opacity: 1; 
            }
            75% { 
                transform: scale(1.3) rotate(270deg); 
                opacity: 0.8; 
            }
            90% { 
                transform: scale(1.1) rotate(360deg); 
                opacity: 0.5; 
            }
            100% { 
                transform: scale(0) rotate(360deg); 
                opacity: 0; 
            }
        }

        /* Screen shake effect for Peak cards */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-2px); }
            20%, 40%, 60%, 80% { transform: translateX(2px); }
        }

        /* Spin animation for clock */
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Footer Styles */
        footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(0, 0, 0, 0.9);
            color: #999;
            font-size: 12px;
            padding: 8px 12px;
            text-align: center;
            border-top: 1px solid #444;
            z-index: 100;
            backdrop-filter: blur(5px);
        }

        footer a {
            color: #667eea;
            text-decoration: none;
            transition: color 0.2s;
        }

        footer a:hover {
            color: #88a7ff;
            text-decoration: underline;
        }

        @media (max-width: 768px) {
            footer {
                font-size: 11px;
                padding: 6px 10px;
            }
        }

        @media (max-width: 480px) {
            footer {
                font-size: 10px;
                padding: 5px 8px;
            }
        }
    </style>
</head>
<body>
    <button class="rules-toggle" onclick="toggleRules()">üìñ Rules</button>
    
    <div class="rules-panel" id="rulesPanel">
        <h3>Peak Card Game Rules</h3>
        <ul>
            <li><strong>Players:</strong> Exactly 4 players</li>
            <li><strong>Starting Cards:</strong> 7 per player</li>
            <li><strong>Cannot finish on:</strong> Cards 1-4, Peak, Reverse, Star, Goblin, Pause</li>
            <li><strong>Can finish on:</strong> Cards 5-6</li>
            <li><strong>Can finish on 8-10:</strong> Only if high card played this round</li>
            <li><strong>Peak cards:</strong> ‚õ∞Ô∏è Next player draws 5 cards</li>
            <li><strong>Reverse cards:</strong> üîÑ Changes play direction</li>
            <li><strong>Star cards:</strong> ‚ú® Removes all Peak cards from other players</li>
            <li><strong>Goblin cards:</strong> üëπ Gives bad cards (1-4) to all other players</li>
            <li><strong>Pause cards:</strong> ‚è∏Ô∏è Pauses another player for 2 minutes</li>
            <li><strong>Disqualified:</strong> Over 20 cards</li>
            <li><strong>Winner:</strong> Last player standing</li>
        </ul>
    </div>

    <div class="game-container">
        <div class="game-header">
            <div class="title-container">
                <div class="peak-cards">
                    <div class="peak-card">P</div>
                    <div class="peak-card">E</div>
                    <div class="peak-card">A</div>
                    <div class="peak-card">K</div>
                </div>
                <div class="subtitle">Card Game</div>
            </div>
        </div>

        <div class="game-info">
            <button class="settings-gear" onclick="openSettings()" title="Game Settings">
                ‚öôÔ∏è
            </button>
            <div class="info-item">
                <div class="info-label">Round</div>
                <div class="info-value" id="roundNumber">1</div>
            </div>
            <div class="info-item">
                <div class="info-label">Cards in Deck</div>
                <div class="info-value" id="deckCount">58</div>
            </div>
            <div class="info-item">
                <div class="info-label">High Card Played</div>
                <div class="info-value" id="highCardPlayed">‚ùå</div>
            </div>
            <div class="info-item">
                <div class="info-label">Current Player</div>
                <div class="info-value" id="currentPlayer">-</div>
            </div>
            <div class="info-item">
                <div class="info-label">Direction</div>
                <div class="info-value" id="gameDirection">üîÑ</div>
            </div>
        </div>

        <div id="gameMessages"></div>

        <div class="game-table">
            <div class="players-container" id="playersContainer">
                <!-- Players will be generated here -->
            </div>
            <div class="table-center">
                <div class="discard-pile-center">
                    <div class="discard-label">Last Played</div>
                    <div id="lastPlayedCard">
                        <div class="card regular" style="margin: 0 auto; background: #ddd; color: #666;">No Card Yet</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="controls">
            <button class="btn draw" id="drawBtn" onclick="drawCard().catch(console.error)" disabled>üÉè DRAW CARD</button>
            <button class="btn quit" id="gameActionBtn" onclick="handleGameAction()">üîÑ NEW GAME</button>
            <button class="btn" onclick="showGameState()">üìä GAME STATE</button>
        </div>
        

    </div>

    <!-- Setup Modal -->
    <div class="modal" id="setupModal">
        <div class="modal-content">
            <div class="title-container modal-title">
                <div class="peak-cards">
                    <div class="peak-card">P</div>
                    <div class="peak-card">E</div>
                    <div class="peak-card">A</div>
                    <div class="peak-card">K</div>
                </div>
                <div class="subtitle">Card Game</div>
            </div>
            <div id="startScreen" class="setup-form" style="margin-top: -10px;">
                <p style="margin-top: 5px; margin-bottom: 5px;">Enter your name:</p>
                <input type="text" class="player-input" id="playerName" placeholder="Your Name" maxlength="20" style="margin-bottom: 10px;">
                
                <div id="gameTypeSection" style="margin: 20px 0;">
                    <p>Choose game mode:</p>
                    <div style="display: flex; gap: 10px; justify-content: center; margin: 10px 0; flex-wrap: wrap;">
                        <button class="btn" onclick="startLocalGame()" style="flex: 1; min-width: 120px; background: linear-gradient(145deg, #667eea, #764ba2);">
                            üè† Local Game
                        </button>
                        <button class="btn" onclick="startOnlineMode()" style="flex: 1; min-width: 120px; background: linear-gradient(145deg, #f093fb, #f5576c);">
                            üåê Online Game
                        </button>
                    </div>
                </div>

                <div id="playerCountSection" style="margin: 20px 0; display: none;">
                    <p>Choose number of players:</p>
                    <div class="player-count-options" style="display: flex; gap: 10px; justify-content: center; margin: 10px 0;">
                        <button class="player-count-btn" data-count="2">
                            <span class="count-emoji">üë•</span>
                            <span class="count-text">2 Players</span>
                            <span class="count-desc">(You + 1 friend)</span>
                        </button>
                        <button class="player-count-btn" data-count="3">
                            <span class="count-emoji">üë®‚Äçüë©‚Äçüëß</span>
                            <span class="count-text">3 Players</span>
                            <span class="count-desc">(You + 2 friends)</span>
                        </button>
                        <button class="player-count-btn" data-count="4">
                            <span class="count-emoji">üë®‚Äçüë©‚Äçüëß‚Äçüë¶</span>
                            <span class="count-text">4 Players</span>
                            <span class="count-desc">(You + 3 friends)</span>
                        </button>
                    </div>
                </div>

                <div id="onlinePlayerCountSection" style="margin: 20px 0; display: none;">
                    <p>Find opponents:</p>
                    <div class="player-count-options" style="display: flex; gap: 10px; justify-content: center; margin: 10px 0;">
                        <button class="player-count-btn online-mode" data-count="2">
                            <span class="count-emoji">üë•</span>
                            <span class="count-text">1v1</span>
                            <span class="count-desc">(2 Players)</span>
                        </button>
                        <button class="player-count-btn online-mode" data-count="3">
                            <span class="count-emoji">üë®‚Äçüë©‚Äçüëß</span>
                            <span class="count-text">1v1v1</span>
                            <span class="count-desc">(3 Players)</span>
                        </button>
                        <button class="player-count-btn online-mode" data-count="4">
                            <span class="count-emoji">üë®‚Äçüë©‚Äçüëß‚Äçüë¶</span>
                            <span class="count-text">Free For All</span>
                            <span class="count-desc">(4 Players)</span>
                        </button>
                    </div>
                </div>
                
                <p style="margin-top: 10px; margin-bottom: 5px;">Game PIN:</p>
                <input type="text" class="player-input" id="gamePin" placeholder="Enter 4-digit PIN" maxlength="4" pattern="[0-9]{4}" style="margin-bottom: 10px;">
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="btn" onclick="createGame()" id="createGameBtn" style="flex: 1;">üéÆ Create Game</button>
                    <button class="btn" onclick="event.preventDefault(); joinGame();" id="joinBtn" disabled style="flex: 1;">üö™ Join Game</button>
                </div>
                
                <!-- Audio Controls -->
                <div class="audio-controls-main">
                    <button class="audio-btn" id="startMusicBtn" onclick="startMusicManually()" title="Start Background Music" style="display: none;">
                        üéµ START MUSIC
                    </button>
                    <button class="audio-btn" id="musicToggle" onclick="toggleMusic()" title="Toggle Background Music">
                        üéµ <span id="musicStatus">ON</span>
                    </button>
                    <button class="audio-btn" id="sfxToggle" onclick="toggleSFX()" title="Toggle Sound Effects">
                        üîä <span id="sfxStatus">ON</span>
                    </button>
                    <div class="volume-control">
                        <span>üîâ</span>
                        <input type="range" id="volumeSlider" min="0" max="100" value="50" onchange="setVolume(this.value)">
                    </div>
                </div>
                
                <div id="gameCreationControls" style="display: none; margin-top: 15px;">
                    <button class="btn" onclick="resetGameCreation()" style="background: linear-gradient(145deg, #95a5a6, #7f8c8d);">‚Ü©Ô∏è Back</button>
                </div>
            </div>
            
            <div id="lobbyScreen" class="setup-form" style="display: none;">
                <div class="title-container modal-title">
                    <div class="peak-cards">
                        <div class="peak-card">P</div>
                        <div class="peak-card">E</div>
                        <div class="peak-card">A</div>
                        <div class="peak-card">K</div>
                    </div>
                    <div class="subtitle">Game Lobby</div>
                </div>
                <div id="gamePinDisplay" style="font-size: 2em; font-weight: bold; color: #4CAF50; margin: 10px 0;"></div>
                <div id="playerCountDisplay" style="font-size: 1.2em; font-weight: bold; color: #666; margin: 5px 0;"></div>
                <div id="shareableLink" style="margin: 10px 0; padding: 10px; background: #f0f0f0; border-radius: 5px; font-size: 0.9em;">
                    <strong>üîó Quick Share Link:</strong><br>
                    <span id="shareUrl" style="color: #2196F3; word-break: break-all;"></span><br>
                    <button onclick="copyShareLink()" style="margin-top: 5px; padding: 5px 10px; background: #2196F3; color: white; border: none; border-radius: 3px; cursor: pointer;">üìã Copy Link</button>
                </div>
                <p style="font-size: 0.9em; color: #666;">‚úÖ <strong>Share this pin with a friend</strong></p>
                <div id="playersList" style="margin: 20px 0; text-align: left;">
                    <h4>Players Joined:</h4>
                    <ul id="playersUL" style="list-style: none; padding: 0;"></ul>
                </div>
                <div id="waitingMessage" style="color: #666; margin: 10px 0;">Waiting for players...</div>
                <button class="btn" onclick="startGameFromLobby()" id="startGameBtn" disabled style="margin-top: 20px;">üöÄ Start Game</button>
                <button class="btn quit" onclick="leaveLobby()" style="margin-top: 10px;">üö™ Leave Lobby</button>
            </div>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div class="modal" id="gameOverModal">
        <div class="modal-content">
            <h2 id="gameOverTitle">üéâ Game Over!</h2>
            <p id="gameOverMessage"></p>
            <div id="gameOverButtons" style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
                <button class="btn" id="playAgainBtn" onclick="handlePlayAgain()" style="flex: 1;">üîÑ Play Again</button>
                <button class="btn" id="leaveGameBtn" onclick="handleLeaveGame()" style="flex: 1; background-color: #ff6b6b;">‚ùå Leave Game</button>
                <button class="btn" id="endGameBtn" onclick="handleEndGame()" style="flex: 1; background-color: #ff6b6b; display: none;">‚èπÔ∏è End Game</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>‚öôÔ∏è Game Settings</h2>
                <button class="close-btn" onclick="closeSettings()">√ó</button>
            </div>
            
            <div class="settings-section">
                <h3>üéµ Audio Settings</h3>
                
                <div class="setting-item">
                    <label for="musicToggleModal">Background Music</label>
                    <div class="toggle-switch">
                        <input type="checkbox" id="musicToggleModal" onchange="toggleMusicFromSettings()" checked>
                        <span class="slider"></span>
                    </div>
                </div>
                
                <div class="setting-item">
                    <label for="sfxToggleModal">Sound Effects</label>
                    <div class="toggle-switch">
                        <input type="checkbox" id="sfxToggleModal" onchange="toggleSFXFromSettings()" checked>
                        <span class="slider"></span>
                    </div>
                </div>
                
                <div class="setting-item">
                    <label for="volumeSliderModal">Master Volume</label>
                    <div class="volume-slider-container">
                        <input type="range" id="volumeSliderModal" min="0" max="100" value="50" onchange="setVolumeFromSettings(this.value)">
                        <span id="volumePercent">50%</span>
                    </div>
                </div>
            </div>
            
            <div class="settings-section">
                <h3>ÔøΩ Audio Status</h3>
                <div class="audio-status" id="audioStatus">
                    <p class="loading">üîÑ Testing audio files...</p>
                </div>
            </div>
            
            <div class="settings-section">
                <h3>ÔøΩüéÆ Game Info</h3>
                <div class="game-credits">
                    <p><strong>Peak Card Game</strong></p>
                    <p>Version 1.0</p>
                    <p>Multiplayer card game for 2-4 players</p>
                </div>
            </div>
            
            <div class="modal-footer">
                <button class="btn" onclick="closeSettings()">‚úÖ Done</button>
            </div>
        </div>
    </div>

    <script>
        // Game state
        let game = {
            players: [],
            deck: [],
            discardPile: [],
            currentPlayerIndex: 0,
            roundNumber: 1,
            highCardPlayedThisRound: false,
            gameOver: false,
            winner: null,
            direction: 1  // 1 for clockwise, -1 for counter-clockwise
        };

        // Multiplayer state
        let gameSession = {
            pin: null,
            isHost: false,
            playerName: '',
            playerId: null,
            lobbyPlayers: {}, // Changed to object to match Firebase structure
            gameStarted: false
        };

        // Firebase URL constant
        const FIREBASE_URL = 'https://peakgame-19c4e-default-rtdb.europe-west1.firebasedatabase.app';
        
        let isConnectedToFirebase = false;
        let gameInitializationComplete = false;  // Flag to skip checkGameOver on first display after init

        // Monitor Firebase connection state
        function initializeFirebaseConnection() {
            const connectedRef = firebase.database().ref('.info/connected');
            connectedRef.on('value', (snap) => {
                isConnectedToFirebase = snap.val() === true;
                console.log(isConnectedToFirebase ? 
                    '‚úÖ Connected to Firebase' : 
                    '‚ùå Disconnected from Firebase');
            });
        }

        // Call this when the page loads
        initializeFirebaseConnection();

        // ========== CACHE CLEARING FUNCTIONS ==========
        const APP_VERSION = '1.0.0'; // Update this when making breaking changes
        const CACHE_VERSION_KEY = 'peakgame_cache_version';
        
        // Clear all service worker caches
        async function clearServiceWorkerCaches() {
            if ('caches' in window) {
                try {
                    const cacheNames = await caches.keys();
                    console.log(`üßπ Found ${cacheNames.length} caches to clear`);
                    
                    const deletePromises = cacheNames.map(cacheName => {
                        console.log(`üßπ Clearing cache: ${cacheName}`);
                        return caches.delete(cacheName);
                    });
                    
                    await Promise.all(deletePromises);
                    console.log('‚úÖ All service worker caches cleared');
                    return true;
                } catch (error) {
                    console.error('‚ùå Error clearing caches:', error);
                    return false;
                }
            }
            return false;
        }
        
        // Clear localStorage game data
        function clearGameData() {
            try {
                const keysToKeep = ['peakgame_player_name', 'peakgame_volume_settings'];
                const allKeys = Object.keys(localStorage);
                let clearedCount = 0;
                
                allKeys.forEach(key => {
                    if (!keysToKeep.includes(key) && key.startsWith('peakgame_')) {
                        localStorage.removeItem(key);
                        clearedCount++;
                        console.log(`üßπ Cleared: ${key}`);
                    }
                });
                
                console.log(`‚úÖ Cleared ${clearedCount} game data items from localStorage`);
                return clearedCount;
            } catch (error) {
                console.error('‚ùå Error clearing game data:', error);
                return 0;
            }
        }
        
        // Full cache and data clear
        async function fullCacheClear() {
            console.log('üßπ Starting full cache clear...');
            
            // Clear service worker caches
            await clearServiceWorkerCaches();
            
            // Clear game data
            clearGameData();
            
            // Update cache version
            localStorage.setItem(CACHE_VERSION_KEY, APP_VERSION);
            
            console.log('‚úÖ Full cache clear complete! Please refresh the page.');
            showMessage('üßπ Cache cleared! Refreshing the page...', 'success');
            
            // Refresh page after 2 seconds
            setTimeout(() => {
                location.reload(true); // Hard refresh
            }, 2000);
        }
        
        // Auto-clear caches on version change
        async function checkAndClearCacheIfNeeded() {
            const cachedVersion = localStorage.getItem(CACHE_VERSION_KEY);
            
            if (cachedVersion !== APP_VERSION) {
                console.log(`üì¶ App version changed (${cachedVersion} -> ${APP_VERSION}). Clearing caches...`);
                await clearServiceWorkerCaches();
                clearGameData();
                localStorage.setItem(CACHE_VERSION_KEY, APP_VERSION);
                console.log('‚úÖ Caches automatically cleared due to version update');
            }
        }

        async function saveGameToCloud(pin, gameData) {
            try {
                if (!isConnectedToFirebase) {
                    console.error('‚ùå Cannot save game: Not connected to Firebase');
                    throw new Error('Not connected to game server');
                }

                console.log('üîÑ Attempting to save game to Firebase using SDK...');
                const database = firebase.database();
                const gameRef = database.ref('games/' + pin);
                
                // First check if a game with this PIN already exists
                const snapshot = await gameRef.once('value');
                if (snapshot.exists()) {
                    console.error('‚ùå Game with PIN ' + pin + ' already exists');
                    throw new Error('Game with this PIN already exists');
                }

                // Save the game data
                await gameRef.set(gameData);
                console.log('‚úÖ Game saved to Firebase:', pin);
                
                // Verify the save was successful
                const verifySnapshot = await gameRef.once('value');
                if (!verifySnapshot.exists()) {
                    throw new Error('Game data was not saved properly');
                }
                
                return true;
            } catch (error) {
                console.error('‚ùå Error saving to Firebase:', error);
                alert('Error: ' + error.message + '. Please try again.');
                return false;
            }
        }

        // Save the ENTIRE game state to Firebase (not just lobby)
        async function saveGameStateToCloud(pin, gameState) {
            try {
                const response = await fetch(`${FIREBASE_URL}/games/${pin}/gameState.json`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(gameState)
                });
                
                if (response.ok) {
                    console.log('‚úÖ Game state saved to Firebase:', pin);
                    return true;
                } else {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
            } catch (error) {
                console.error('‚ùå Error saving game state to Firebase:', error);
                return false;
            }
        }

        // Load the ENTIRE game state from Firebase
        async function loadGameStateFromCloud(pin) {
            try {
                const response = await fetch(`${FIREBASE_URL}/games/${pin}/gameState.json`);
                
                if (response.ok) {
                    const data = await response.json();
                    if (data) {
                        // Silently return data (avoid console spam from polling every second)
                        return data;
                    }
                }
                return null;
            } catch (error) {
                console.error('‚ùå Error loading game state from Firebase:', error);
                return null;
            }
        }

        // Reconstruct game state with proper Card and Player objects
        function reconstructGameState(gameState) {
            const reconstructedGame = {
                players: gameState.players.map(playerData => {
                    const player = new Player(playerData.name);
                    player.hand = playerData.hand.map(cardData => new Card(cardData.value, cardData.type));
                    player.isDisqualified = playerData.isDisqualified;
                    player.hasFinished = playerData.hasFinished;
                    player.isPaused = playerData.isPaused || false;
                    player.pausedUntil = playerData.pausedUntil || 0;
                    return player;
                }),
                deck: gameState.deck.map(cardData => new Card(cardData.value, cardData.type)),
                discardPile: gameState.discardPile.map(cardData => new Card(cardData.value, cardData.type)),
                currentPlayerIndex: gameState.currentPlayerIndex,
                roundNumber: gameState.roundNumber,
                highCardPlayedThisRound: gameState.highCardPlayedThisRound,
                gameOver: gameState.gameOver,
                winner: gameState.winner,
                direction: gameState.direction
            };
            return reconstructedGame;
        }

        async function loadGameFromCloud(pin) {
            try {
                // Use REST API instead of Firebase SDK to avoid excessive logging and connection issues
                const response = await fetch(`${FIREBASE_URL}/games/${pin}.json`);
                
                if (response.ok) {
                    const data = await response.json();
                    if (data) {
                        // Silently return data
                        return data;
                    }
                    return null;
                }
                return null;
            } catch (error) {
                // Silently handle errors
                return null;
            }
        }

        function startRealTimeListener(pin) {
            console.log('üîÑ Starting real-time listener for PIN:', pin);
            const gameRef = firebase.database().ref(`games/${pin}`);
            
            // Remove any existing listeners first
            gameRef.off();
            
            // Listen for changes to the game data
            gameRef.on('value', (snapshot) => {
                const data = snapshot.val();
                if (!data) {
                    console.error('‚ùå Game data not found in real-time update');
                    return;
                }
                
                console.log('üì• Received real-time update:', data);
                
                // Update local game session with new data
                if (data.lobbyPlayers) {
                    // Store previous player count for comparison
                    const previousCount = gameSession.lobbyPlayers ? Object.keys(gameSession.lobbyPlayers).length : 0;
                    
                    console.log('Previous lobby state:', gameSession.lobbyPlayers);
                    console.log('New lobby data:', data.lobbyPlayers);
                    
                    // Update local game session
                    gameSession.lobbyPlayers = data.lobbyPlayers;
                    
                    // Get current player count from the object
                    const playerCount = Object.keys(data.lobbyPlayers).length;
                    console.log(`üë• Current player count: ${playerCount}/${data.maxPlayers || 4}`);
                    
                    // Update waiting message
                    const waitingMessage = document.getElementById('waitingMessage');
                    if (waitingMessage) {
                        const maxPlayers = data.maxPlayers || 4;
                        if (playerCount < maxPlayers) {
                            waitingMessage.textContent = `Waiting for ${maxPlayers - playerCount} more players... (${playerCount}/${maxPlayers})`;
                        } else if (!gameSession.isHost) {
                            waitingMessage.textContent = 'Waiting for host to start the game...';
                        } else {
                            waitingMessage.textContent = 'Ready to start!';
                        }
                    }
                    
                    // Always update the lobby display when we get new player data
                    updateLobbyDisplay();
                    
                    // Enable/disable start button for host
                    const startBtn = document.getElementById('startGameBtn');
                    if (startBtn && gameSession.isHost) {
                        const canStart = playerCount >= (data.maxPlayers || 4);
                        startBtn.disabled = !canStart;
                        startBtn.style.opacity = canStart ? '1' : '0.5';
                    }
                    
                    // Play sound and show notification when new player joins
                    if (gameSession.isHost && playerCount > previousCount) {
                        console.log('üéÆ New player joined!');
                        audioManager?.playSound('buttonClick');
                        
                        // Show a temporary notification
                        const notification = document.createElement('div');
                        notification.textContent = 'New player joined!';
                        notification.style.cssText = `
                            position: fixed;
                            top: 20px;
                            right: 20px;
                            background: #4CAF50;
                            color: white;
                            padding: 10px 20px;
                            border-radius: 5px;
                            animation: fadeInOut 2s forwards;
                        `;
                        document.body.appendChild(notification);
                        setTimeout(() => notification.remove(), 2000);
                    }
                }
                
                gameSession.gameStarted = data.gameStarted;
                
                // Always update the display when we get new data
                updateLobbyDisplay();
                
                // Play a sound when a new player joins (if we're the host)
                if (gameSession.isHost && Object.keys(data.lobbyPlayers).length > Object.keys(gameSession.lobbyPlayers || {}).length) {
                    audioManager?.playSound('buttonClick');
                }
                
                // If game has started, handle that
                if (data.gameStarted && !gameSession.gameStarted) {
                    handleGameStart();
                }
            });
        }

        async function loadGameFromCloudOld(pin) {
            try {
                const response = await fetch(`${FIREBASE_URL}/games/${pin}.json`);
                
                if (response.ok) {
                    const data = await response.json();
                    if (data && data.pin) {
                        console.log('‚úÖ Game loaded from Firebase:', pin);
                        return data;
                    } else {
                        console.log('‚ùå Game not found in Firebase:', pin);
                        return null;
                    }
                } else {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
            } catch (error) {
                console.error('‚ùå Error loading from Firebase:', error);
                return null;
            }
        }

        async function removeGameFromCloud(pin) {
            try {
                const response = await fetch(`${FIREBASE_URL}/games/${pin}.json`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    console.log('‚úÖ Game removed from Firebase:', pin);
                } else {
                    console.error('‚ùå Error removing game from Firebase');
                }
            } catch (error) {
                console.error('‚ùå Error removing from Firebase:', error);
            }
        }

        // Real-time listener for Firebase updates
        let gameUpdateListener = null;
        let gameStateListener = null;

        function startRealTimeListener(pin) {
            if (gameUpdateListener) {
                stopRealTimeListener();
            }

            console.log('üîÑ Starting real-time listener for PIN:', pin);
            
            // Use Firebase's real-time database reference
            const gameRef = firebase.database().ref(`games/${pin}`);
            
            // Listen for value changes
            gameUpdateListener = gameRef.on('value', (snapshot) => {
                try {
                    const updatedSession = snapshot.val();
                    if (updatedSession && updatedSession.lobbyPlayers) {
                        // Store previous player count for comparison
                        const previousCount = gameSession.lobbyPlayers ? Object.keys(gameSession.lobbyPlayers).length : 0;

                        console.log('ÔøΩ Previous lobby state:', gameSession.lobbyPlayers);
                        console.log('üì• New lobby data:', updatedSession.lobbyPlayers);
                        
                        // Update local game session
                        gameSession.lobbyPlayers = updatedSession.lobbyPlayers;
                        
                        // Get current player count
                        const currentCount = Object.keys(updatedSession.lobbyPlayers).length;
                        console.log(`üë• Lobby updated! Player count: ${previousCount} -> ${currentCount}`);
                        
                        // IMPORTANT: Update the lobby display whenever we get new player data
                        updateLobbyDisplay();
                        
                        // Process animation broadcasts
                        processAnimationBroadcasts(updatedSession);
                        
                        // Check if game has started
                        if (updatedSession.gameStarted && !gameSession.gameStarted) {
                            gameSession.gameStarted = true;
                            
                            // Convert lobbyPlayers object to array for non-host players
                            const lobbyPlayersArray = Array.isArray(updatedSession.lobbyPlayers) 
                                ? updatedSession.lobbyPlayers 
                                : Object.values(updatedSession.lobbyPlayers);
                            
                            // Initialize basic game state for non-host players using proper Player objects
                            game = {
                                players: lobbyPlayersArray.map(p => new Player(p.name)),
                                deck: updatedSession.deck || [],
                                discardPile: updatedSession.discardPile || [],
                                currentPlayerIndex: updatedSession.currentPlayerIndex || 0,
                                roundNumber: updatedSession.roundNumber || 1,
                                highCardPlayedThisRound: updatedSession.highCardPlayedThisRound || false,
                                gameOver: updatedSession.gameOver || false,
                                winner: updatedSession.winner || null,
                                direction: updatedSession.direction || 1
                            };
                            
                            // Hide lobby and show game
                            document.getElementById('setupModal').style.display = 'none';
                            showMessage('Game started!', 'success');
                            updateDisplay();
                            
                            // Start listening for real game state
                            startGameStateListener(pin);
                        }
                    } else if (!updatedSession) {
                        console.log('‚ö†Ô∏è Game session no longer exists');
                    }
                } catch (error) {
                    console.error('‚ùå Error in real-time listener:', error);
                }
            });
        }

        // Separate listener for game state during gameplay
        function startGameStateListener(pin) {
            if (gameStateListener) {
                stopGameStateListener();
            }

            console.log('üéÆ Starting game state listener for PIN:', pin);
            let lastTimestamp = 0;
            
            gameStateListener = setInterval(async () => {
                try {
                    const gameState = await loadGameStateFromCloud(pin);
                    
                    // Load animations from REST API (don't use Firebase SDK to avoid spam)
                    try {
                        const animResponse = await fetch(`${FIREBASE_URL}/games/${pin}/animations.json`);
                        if (animResponse.ok) {
                            const animations = await animResponse.json();
                            if (animations) {
                                gameState.animations = animations;
                            }
                        }
                    } catch (error) {
                        // Silently skip animation loading if it fails
                    }
                    
                    if (gameState && gameState.timestamp && gameState.timestamp > lastTimestamp) {
                        // Process animation broadcasts
                        processAnimationBroadcasts(gameState);
                        
                        // Always update critical game state from Firebase for consistency
                        // This includes currentPlayerIndex which MUST be in sync across all clients
                        game.currentPlayerIndex = gameState.currentPlayerIndex || 0;
                        game.roundNumber = gameState.roundNumber || 1;
                        game.highCardPlayedThisRound = gameState.highCardPlayedThisRound || false;
                        game.gameOver = gameState.gameOver || false;
                        game.winner = gameState.winner || null;
                        game.direction = gameState.direction || 1;
                        
                        // Don't update player hands and deck if this player just made the move
                        // (they already have the updated local version)
                        if (gameState.lastMoveBy !== gameSession.playerName) {
                            // Reconstruct Player objects properly from Firebase data
                            if (gameState.players) {
                                game.players = gameState.players.map(p => {
                                    const player = new Player(p.name);
                                    // Reconstruct Card objects in player's hand
                                    player.hand = (p.hand || []).map(cardData => new Card(cardData.value, cardData.type));
                                    player.active = p.active !== undefined ? p.active : true;
                                    player.isDisqualified = p.isDisqualified || false;
                                    player.hasFinished = p.hasFinished || false;
                                    player.isPaused = p.isPaused || false;
                                    player.pausedUntil = p.pausedUntil || 0;
                                    return player;
                                });
                            }
                            
                            // Reconstruct Card objects in deck and discard pile
                            game.deck = (gameState.deck || game.deck || []).map(cardData => new Card(cardData.value, cardData.type));
                            game.discardPile = (gameState.discardPile || []).map(cardData => new Card(cardData.value, cardData.type));
                            
                            // Check if game is over and show winner to all players
                            if (game.gameOver && game.winner) {
                                showGameOver(`üéâ ${game.winner.name} wins!`);
                            } else if (game.gameOver && !game.winner) {
                                showGameOver("üòû Game ended with no winner.");
                            }
                            
                            // Update display for all players
                            updateDisplay();
                        }
                        lastTimestamp = gameState.timestamp;
                    }
                } catch (error) {
                    console.error('‚ùå Error in game state listener:', error);
                }
            }, 1000); // Check every 1 second for faster gameplay
        }

        function stopGameStateListener() {
            if (gameStateListener) {
                clearInterval(gameStateListener);
                gameStateListener = null;
                console.log('‚èπÔ∏è Stopped game state listener');
            }
        }

        function stopRealTimeListener() {
            if (gameUpdateListener) {
                clearInterval(gameUpdateListener);
                gameUpdateListener = null;
                console.log('‚èπÔ∏è Stopped real-time listener');
            }
            stopGameStateListener();
        }

        // Alternative sharing method for GitHub Pages
        function generateShareableLink(pin) {
            const baseUrl = 'https://peakgame-19c4e.web.app/';
            return `${baseUrl}?pin=${pin}`;
        }

        // Check for PIN in URL when page loads
        function checkUrlForPin() {
            const urlParams = new URLSearchParams(window.location.search);
            const pin = urlParams.get('pin');
            if (pin && pin.length === 4 && /^\d{4}$/.test(pin)) {
                document.getElementById('gamePin').value = pin;
                console.log('üîó PIN found in URL:', pin);
            }
        }

        // Card types
        const CardType = {
            REGULAR: 'regular',
            PEAK: 'peak',
            REVERSE: 'reverse',
            STAR: 'star',
            GOBLIN: 'goblin',
            PAUSE: 'pause'
        };

        // Card class
        class Card {
            constructor(value, type = CardType.REGULAR) {
                this.value = value;
                this.type = type;
            }

            toString() {
                if (this.type === CardType.PEAK) return 'PEAAAKKK';
                if (this.type === CardType.REVERSE) return '‚Ü©Ô∏èREVERSE';
                if (this.type === CardType.STAR) return '‚ú®STAR';
                if (this.type === CardType.GOBLIN) return 'üëπGOBLIN';
                if (this.type === CardType.PAUSE) return '‚è∏Ô∏èPAUSE';
                return this.value.toString();
            }

            isPeakCard() {
                return this.type === CardType.PEAK;
            }

            canFinishOn() {
                // Special cards cannot be finished on
                if (this.isPeakCard() || this.isReverseCard() || this.isStarCard() || this.isGoblinCard() || this.isPauseCard()) return false;
                if (this.value >= 1 && this.value <= 4) return false;
                if (this.value >= 5 && this.value <= 6) return true;
                if (this.value >= 8 && this.value <= 10) return true;
                return false;
            }

            isReverseCard() {
                return this.type === CardType.REVERSE;
            }

            isStarCard() {
                return this.type === CardType.STAR;
            }

            isGoblinCard() {
                return this.type === CardType.GOBLIN;
            }

            isPauseCard() {
                return this.type === CardType.PAUSE;
            }
        }

        // Player class
        class Player {
            constructor(name) {
                this.name = name;
                this.hand = [];
                this.isDisqualified = false;
                this.hasFinished = false;
                this.isPaused = false;
                this.pausedUntil = 0;
            }

            addCard(card) {
                console.log(`üì• Adding card ${card.toString()} to ${this.name}'s hand`);
                console.log(`üë§ ${this.name} hand before: ${this.hand.length} cards`);
                this.hand.push(card);
                console.log(`üë§ ${this.name} hand after: ${this.hand.length} cards`);
                
                if (this.hand.length > 20) {
                    this.isDisqualified = true;
                    console.log(`‚ùå ${this.name} disqualified for having ${this.hand.length} cards`);
                }
            }

            addCards(cards) {
                for (let card of cards) {
                    this.addCard(card);
                }
            }

            removeCard(card) {
                const index = this.hand.findIndex(c => c.value === card.value && c.type === card.type);
                if (index !== -1) {
                    this.hand.splice(index, 1);
                    return true;
                }
                return false;
            }

            isActive() {
                return !this.isDisqualified && !this.hasFinished;
            }

            canTakeTurn() {
                if (!this.isActive()) return false;
                if (this.isPaused && Date.now() < this.pausedUntil) return false;
                
                // Auto-unpause if pause time has expired
                if (this.isPaused && Date.now() >= this.pausedUntil) {
                    this.isPaused = false;
                    this.pausedUntil = 0;
                }
                
                return true;
            }
        }

        // Game functions
        function createDeck() {
            const deck = [];
            // Add regular cards 1-10 (multiple copies to have enough cards)
            for (let copy = 0; copy < 6; copy++) {  // 6 copies of each number = 60 cards
                for (let i = 1; i <= 10; i++) {
                    deck.push(new Card(i, CardType.REGULAR));
                }
            }
            // Add 10 Peak cards
            for (let i = 0; i < 10; i++) {
                deck.push(new Card(0, CardType.PEAK));
            }
            // Add 12 Reverse cards
            for (let i = 0; i < 12; i++) {
                deck.push(new Card(0, CardType.REVERSE));
            }
            // Add 8 Star cards (removes Peak cards from others)
            for (let i = 0; i < 8; i++) {
                deck.push(new Card(0, CardType.STAR));
            }
            // Add 7 Goblin cards (gives bad cards to others)
            for (let i = 0; i < 7; i++) {
                deck.push(new Card(0, CardType.GOBLIN));
            }
            // Add just 1 rare Pause card (the most powerful special card)
            deck.push(new Card(0, CardType.PAUSE));
            // Show special message when the Pause card is dealt
            const pauseCard = deck[deck.length - 1];
            pauseCard.isRare = true; // Mark it as a rare card
            
            return shuffleDeck(deck);  // Now we have 98 total cards (60 regular + 10 Peak + 12 Reverse + 8 Star + 7 Goblin + 1 Pause)
        }

        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        function dealCards() {
            for (let player of game.players) {
                for (let i = 0; i < 7; i++) {
                    if (game.deck.length > 0) {
                        const card = game.deck.pop();
                        player.addCard(card);
                        
                        // Special handling for the rare Pause card
                        if (card.type === CardType.PAUSE && card.isRare) {
                            // Play special animation and sound for everyone
                            playSpecialCardAnimationEnhanced('legendary');
                            showMessage(`üéâ ${player.name} has received the Legendary Pause Card! A rare and powerful artifact!`, 'special');
                            // Extra visual feedback for the lucky player
                            if (player.name === gameSession.playerName) {
                                triggerVibration([100, 200, 300, 200, 100]); // Special vibration pattern
                                showMessage('‚ú® You have been chosen! The Legendary Pause Card is now yours!', 'legendary');
                            }
                        }
                    }
                }
            }
        }

        function canPlayCard(card, lastCard = null) {
            // Special cards can always be played
            if (card.isPeakCard() || card.isReverseCard() || card.isStarCard() || card.isGoblinCard() || card.isPauseCard()) return true;
            if (!lastCard) return true;
            if (lastCard.isPeakCard() || lastCard.isReverseCard() || lastCard.isStarCard() || lastCard.isGoblinCard() || lastCard.isPauseCard()) return true;
            
            // Regular cards follow adjacency rules
            if (card.type === CardType.REGULAR && lastCard.type === CardType.REGULAR) {
                const diff = Math.abs(card.value - lastCard.value);
                return diff <= 1;
            }
            return false;
        }

        function canFinishOnCard(card, highCardPlayed = false) {
            // Cannot finish on any special cards
            if (card.isPeakCard() || card.isReverseCard() || card.isStarCard() || 
                card.isGoblinCard() || card.isPauseCard()) {
                return false;
            }

            // Rules for regular number cards:
            // 1-4: Cannot finish on these
            if (card.value >= 1 && card.value <= 4) return false;

            // 5-6: Can always finish on these
            if (card.value >= 5 && card.value <= 6) return true;

            // 7: Can never finish on this (middle card)
            if (card.value === 7) return false;

            // 8-10: Can only finish if someone else played a high card this round
            if (card.value >= 8 && card.value <= 10) return highCardPlayed;

            return false;
        }

        function isHighValueCard(card) {
            // Only regular number cards 8-10 are considered high value
            return card.type === CardType.REGULAR && card.value >= 8 && card.value <= 10;
        }

        async function playCard(playerIndex, cardIndex) {
            const player = game.players[playerIndex];
            const card = player.hand[cardIndex];
            
            if (!player || !card) {
                return false;
            }

            // Check if it's this player's turn
            if (game.currentPlayerIndex !== playerIndex) {
                showMessage("It's not your turn! Wait for your turn to play.", 'error');
                audioManager?.playSound('loseSound', 0.3);
                return false;
            }

            // Check if this is the current user trying to play
            if (player.name !== gameSession.playerName) {
                showMessage("You can only play your own cards!", 'error');
                audioManager?.playSound('loseSound', 0.3);
                return false;
            }

            // First save the game state to prevent race conditions
            const cardGameRef = firebase.database().ref(`games/${gameSession.pin}`);
            await cardGameRef.update({
                'lastAction': {
                    type: 'cardPlayed',
                    playerIndex: playerIndex,
                    cardIndex: cardIndex,
                    timestamp: firebase.database.ServerValue.TIMESTAMP
                }
            });

            // Remove card from player's hand and add to discard pile
            const cardToRemove = player.hand.splice(cardIndex, 1)[0];
            game.discardPile.push(cardToRemove);
            
            // Play base card sound and show card played animation
            audioManager?.playSound(cardToRemove.isPeakCard() ? 'peakCard' : 'cardPlace');
            
            // Update Firebase immediately with the new game state
            await saveGameStateToCloud(gameSession.pin, {
                players: game.players,
                discardPile: game.discardPile,
                currentPlayerIndex: game.currentPlayerIndex,
                timestamp: firebase.database.ServerValue.TIMESTAMP
            });
            
            // Update the display immediately to show the played card
            updateDisplay();

            // Check if high value card was played
            if (isHighValueCard(cardToRemove)) {
                game.highCardPlayedThisRound = true;
                showMessage(`üéØ High card ${cardToRemove.value} played by ${player.name}! Others can now finish on cards 8-10.`, 'info');
                
                // Update high card status in Firebase
                await cardGameRef.update({
                    'highCardPlayedThisRound': true
                });
            }

            // Show initial play message
            showMessage(`${player.name} played ${cardToRemove}`, 'success');

            // Calculate next player index BEFORE handling special cards
            // This is needed so Peak card gives to the RIGHT player
            const nextPlayerIndex = (game.currentPlayerIndex + game.direction + game.players.length) % game.players.length;
            
            // Skip eliminated players to find the actual next player
            let actualNextPlayerIndex = nextPlayerIndex;
            while (game.players[actualNextPlayerIndex].isEliminated) {
                actualNextPlayerIndex = (actualNextPlayerIndex + game.direction + game.players.length) % game.players.length;
            }

            // Handle special cards first
            try {
                if (cardToRemove.isPeakCard()) {
                    await handlePeakCard(game.players[actualNextPlayerIndex]);
                } else if (cardToRemove.isReverseCard()) {
                    await handleReverseCard();
                } else if (cardToRemove.isStarCard()) {
                    await handleStarCard();
                } else if (cardToRemove.isGoblinCard()) {
                    await handleGoblinCard();
                } else if (cardToRemove.isPauseCard()) {
                    await handlePauseCard(playerIndex);
                }
            } catch (error) {
                console.error('Error handling special card:', error);
                showMessage('Error handling special card effect', 'error');
            }
            
            // Calculate next player FIRST - before any saves
            let finalNextPlayerIndex = actualNextPlayerIndex;
            for (let i = 0; i < game.players.length; i++) {
                const playerToCheck = game.players[finalNextPlayerIndex];
                if (playerToCheck.canTakeTurn()) {
                    break;
                } else if (playerToCheck.isActive() && playerToCheck.isPaused) {
                    const remainingTime = Math.ceil((playerToCheck.pausedUntil - Date.now()) / 1000);
                    if (remainingTime > 0) {
                        console.log(`‚è∏Ô∏è ${playerToCheck.name} is paused for ${remainingTime} more seconds`);
                        showMessage(`‚è∏Ô∏è ${playerToCheck.name} is paused for ${remainingTime} more seconds`, 'info');
                    }
                }
                finalNextPlayerIndex = (finalNextPlayerIndex + game.direction + game.players.length) % game.players.length;
            }
            
            // Update current player to next player
            game.currentPlayerIndex = finalNextPlayerIndex;
            showMessage(`üéÆ It's ${game.players[game.currentPlayerIndex].name}'s turn!`, 'info');
            
            // NOW save EVERYTHING including the new currentPlayerIndex atomically
            try {
                await saveGameStateToCloud(gameSession.pin, {
                    players: game.players.map(p => ({
                        name: p.name,
                        hand: p.hand,
                        active: p.active,
                        isDisqualified: p.isDisqualified,
                        hasFinished: p.hasFinished,
                        isPaused: p.isPaused,
                        pausedUntil: p.pausedUntil
                    })),
                    deck: game.deck,
                    discardPile: game.discardPile,
                    currentPlayerIndex: finalNextPlayerIndex,
                    roundNumber: game.roundNumber,
                    direction: game.direction,
                    highCardPlayedThisRound: game.highCardPlayedThisRound,
                    lastMoveBy: gameSession.playerName,
                    timestamp: Date.now()
                });
                console.log(`‚úÖ Game state saved: Special effects + next player (${game.players[finalNextPlayerIndex].name})`);
            } catch (error) {
                console.error('‚ùå Failed to save game state:', error);
            }
            
            showMessage(`üéÆ It's ${game.players[game.currentPlayerIndex].name}'s turn!`, 'info');
            
            // Save complete game state
            await saveGameStateToCloud(gameSession.pin, {
                players: game.players.map(p => ({
                    name: p.name,
                    hand: p.hand,
                    active: p.active,
                    isDisqualified: p.isDisqualified,
                    hasFinished: p.hasFinished,
                    isPaused: p.isPaused,
                    pausedUntil: p.pausedUntil
                })),
                deck: game.deck,
                discardPile: game.discardPile,
                currentPlayerIndex: game.currentPlayerIndex,
                roundNumber: game.roundNumber,
                direction: game.direction,
                lastMoveBy: gameSession.playerName,
                timestamp: Date.now()
            });
            
            // Update display to show new turn
            updateDisplay();

            // Check if player finished
            if (player.hand.length === 0) {
                if (canFinishOnCard(cardToRemove, game.highCardPlayedThisRound)) {
                    player.hasFinished = true;
                    showMessage(`üèÜ ${player.name} has finished the game!`, 'success');
                    updateDisplay();
                    await checkGameOver();
                    return true;
                } else {
                    let errorMessage = '';
                    if (cardToRemove.isPeakCard() || cardToRemove.isReverseCard() || 
                        cardToRemove.isStarCard() || cardToRemove.isGoblinCard() || 
                        cardToRemove.isPauseCard()) {
                        errorMessage = `${player.name} cannot finish on a special card!`;
                    } else if (cardToRemove.value >= 1 && cardToRemove.value <= 4) {
                        errorMessage = `${player.name} cannot finish on a low card (1-4)!`;
                    } else if (cardToRemove.value === 7) {
                        errorMessage = `${player.name} cannot finish on a 7!`;
                    } else if (cardToRemove.value >= 8 && cardToRemove.value <= 10 && !game.highCardPlayedThisRound) {
                        errorMessage = `${player.name} cannot finish on ${cardToRemove.value} until someone else plays a high card (8-10)!`;
                    } else {
                        errorMessage = `${player.name} cannot finish on ${cardToRemove}!`;
                    }
                    showMessage(errorMessage, 'error');
                    
                    // Give penalty card
                    if (game.deck.length > 0) {
                        player.addCard(game.deck.pop());
                        showMessage(`${player.name} picks up a penalty card for invalid finish`, 'warning');
                    }
                }
            }
            
            // Update the display immediately
            console.log('üîÑ Updating display...');
            updateDisplay();
            
            // Save game state to Firebase for all players
            if (gameSession.pin) {
                await saveGameStateToCloud(gameSession.pin, {
                    players: game.players.map(p => ({
                        name: p.name,
                        hand: p.hand,
                        active: p.active,
                        isDisqualified: p.isDisqualified,
                        hasFinished: p.hasFinished,
                        isPaused: p.isPaused,
                        pausedUntil: p.pausedUntil
                    })),
                    deck: game.deck,
                    discardPile: game.discardPile,
                    currentPlayerIndex: game.currentPlayerIndex,
                    roundNumber: game.roundNumber,
                    highCardPlayedThisRound: game.highCardPlayedThisRound,
                    gameOver: game.gameOver,
                    winner: game.winner,
                    direction: game.direction,
                    lastMoveBy: gameSession.playerName,
                    timestamp: Date.now()
                });
                console.log('üíæ Game state saved to Firebase after move');
            }
            
            console.log('‚úÖ Card play completed');
            
            return true;
        }

        async function handlePeakCard(nextPlayer) {
            // Broadcast Peak card animation to all players
            broadcastSpecialCardAnimation('peak', game.players[game.currentPlayerIndex].name);
            
            // nextPlayer is passed as the player who should receive the 5 cards
            if (nextPlayer) {
                // CRITICAL: Refill deck if needed before giving cards
                if (game.deck.length === 0 && game.discardPile.length > 0) {
                    const topCard = game.discardPile[game.discardPile.length - 1];
                    game.deck = game.discardPile.slice(0, -1);
                    game.discardPile = [topCard];
                    game.deck = shuffleDeck(game.deck);
                    showMessage(`üîÑ Deck refilled with ${game.deck.length} cards for Peak card!`, 'info');
                }
                
                const cards = [];
                // Give 5 cards or as many as possible from the deck
                for (let i = 0; i < 5 && game.deck.length > 0; i++) {
                    cards.push(game.deck.pop());
                }
                
                if (cards.length > 0) {
                    // Update UI to show cards being drawn
                    showMessage(`üé¥ Drawing ${cards.length} cards for ${nextPlayer.name}...`, 'info');
                    await new Promise(resolve => setTimeout(resolve, 500)); // Dramatic pause
                    
                    // Add cards to next player's hand
                    nextPlayer.addCards(cards);
                    audioManager?.playSound('cardFlip');
                    
                    showMessage(`‚ö° ${nextPlayer.name} picked up ${cards.length} cards due to Peak card!`, 'warning');
                    
                    if (nextPlayer.isDisqualified) {
                        showMessage(`‚ùå ${nextPlayer.name} is disqualified for having over 20 cards!`, 'error');
                        audioManager?.playSound('loseSound');
                    }
                    
                    // Update the display to show new deck count
                    document.getElementById('deckCount').textContent = game.deck.length;
                } else {
                    showMessage(`No cards left in deck to give!`, 'warning');
                }
            } else {
                showMessage(`No next player available!`, 'warning');
            }
        }

        async function handleReverseCard() {
            // Broadcast Reverse card animation to all players
            broadcastSpecialCardAnimation('reverse', game.players[game.currentPlayerIndex].name);
            
            // Add dramatic pause before direction change
            await new Promise(resolve => setTimeout(resolve, 300));
            
            // Flip the direction with visual feedback
            game.direction *= -1;
            const directionText = game.direction === 1 ? 'clockwise ‚Üª' : 'counter-clockwise ‚Ü∫';
            
            // Play sound effect for direction change
            audioManager?.playSound('buttonClick');
            
            // Show direction change message with animation
            showMessage(`üîÑ Direction reversed! Now playing ${directionText}`, 'special');
            
            // Update direction display immediately
            const directionElement = document.getElementById('gameDirection');
            directionElement.textContent = game.direction === 1 ? '‚Üª Clockwise' : '‚Ü∫ Counter-CW';
            directionElement.classList.add('direction-change');
            setTimeout(() => directionElement.classList.remove('direction-change'), 1000);
            
            console.log('üîÑ Game direction changed to:', directionText);
        }

        async function handleStarCard() {
            // Broadcast Star card animation to all players
            broadcastSpecialCardAnimation('star', game.players[game.currentPlayerIndex].name);
            
            // Play star sound effect
            audioManager?.playSound('starSound');
            
            console.log('‚ú® Star card played - removing Peak cards from other players');
            let totalPeakCardsRemoved = 0;
            
            // Process each player with a delay for dramatic effect
            for (let index = 0; index < game.players.length; index++) {
                const player = game.players[index];
                if (index !== game.currentPlayerIndex && player.isActive()) {
                    // Show checking animation
                    showMessage(`‚ú® Checking ${player.name}'s cards...`, 'info');
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Find and remove all Peak cards from this player's hand
                    const peakCards = [];
                    for (let i = player.hand.length - 1; i >= 0; i--) {
                        if (player.hand[i].isPeakCard()) {
                            peakCards.push(player.hand.splice(i, 1)[0]);
                        }
                    }
                    
                    if (peakCards.length > 0) {
                        totalPeakCardsRemoved += peakCards.length;
                        showMessage(`‚≠ê ${player.name} had ${peakCards.length} Peak card(s) removed!`, 'success');
                        audioManager?.playSound('cardPlace');
                        console.log(`Removed ${peakCards.length} Peak cards from ${player.name}`);
                        
                        // Put the Peak cards back into the deck and shuffle
                        game.deck.push(...peakCards);
                        game.deck = shuffleDeck(game.deck);
                        
                        // Update deck count
                        document.getElementById('deckCount').textContent = game.deck.length;
                    }
                }
            }
            
            if (totalPeakCardsRemoved > 0) {
                showMessage(`üåü Star card removed ${totalPeakCardsRemoved} Peak card(s) from other players!`, 'success');
            } else {
                showMessage(`üåü Star card played, but no Peak cards were found to remove`, 'info');
            }
        }

        async function handleGoblinCard() {
            // Broadcast Goblin card animation to all players
            broadcastSpecialCardAnimation('goblin', game.players[game.currentPlayerIndex].name);
            
            // Play goblin sound effect
            audioManager?.playSound('goblinSound');
            
            console.log('üëπ Goblin card played - giving bad cards to other players');
            const badCards = [1, 2, 3, 4]; // Bad cards that can't be finished with
            let affectedPlayers = 0;
            
            // Process each player
            for (let index = 0; index < game.players.length; index++) {
                const player = game.players[index];
                if (index !== game.currentPlayerIndex && player.isActive()) {
                    // Give each other player a random bad card (1-4)
                    const badCardValue = badCards[Math.floor(Math.random() * badCards.length)];
                    const badCard = new Card(badCardValue, CardType.REGULAR);
                    player.addCard(badCard);
                    affectedPlayers++;
                    
                    // Show message with slight delay for dramatic effect
                    await new Promise(resolve => setTimeout(resolve, 500));
                    showMessage(`üëπ ${player.name} received a ${badCardValue} card from the Goblin!`, 'warning');
                    console.log(`Gave ${player.name} a ${badCardValue} card`);
                    
                    if (player.isDisqualified) {
                        showMessage(`${player.name} is disqualified for having over 20 cards!`, 'error');
                    }
                }
            }
            
            // Only show summary message if players were affected
            if (affectedPlayers > 0) {
                showMessage(`üëπ Goblin card cursed ${affectedPlayers} other player${affectedPlayers !== 1 ? 's' : ''} with bad cards!`, 'warning');
            } else {
                showMessage(`üëπ Goblin card played, but no other players were affected!`, 'info');
            }
        }

        function handlePauseCard(currentPlayerIndex) {
            // Broadcast special legendary animation to all players
            broadcastSpecialCardAnimation('pause', game.players[game.currentPlayerIndex].name);
            playSpecialCardAnimationEnhanced('legendary'); // Extra effect for the legendary card
            
            console.log('‚è∏Ô∏è Legendary Pause card played - choosing target player');
            
            // Create a dramatic pause before the effect
            showMessage('üåü The Legendary Pause Card is being activated...', 'special');
            
            // Find all other active players
            const targetPlayers = game.players.filter((player, index) => 
                index !== currentPlayerIndex && player.isActive()
            );
            
            if (targetPlayers.length === 0) {
                showMessage('‚è∏Ô∏è No players available to pause!', 'info');
                return;
            }
            
            // Let the player choose who to pause
            showPlayerSelectionDialog(targetPlayers, async (selectedPlayer) => {
                if (selectedPlayer) {
                    // Set pause timer for 5 minutes (300 seconds)
                    selectedPlayer.pausedUntil = Date.now() + (5 * 60 * 1000);
                    selectedPlayer.isPaused = true;
                    
                    // Also give them 2 bad cards as an extra penalty
                    const badCards = [1, 2, 3, 4];
                    for (let i = 0; i < 2; i++) {
                        const badCardValue = badCards[Math.floor(Math.random() * badCards.length)];
                        const badCard = new Card(badCardValue, CardType.REGULAR);
                        selectedPlayer.addCard(badCard);
                    }
                    
                    showMessage(`üéØ ${selectedPlayer.name} has been frozen in time for 5 minutes!`, 'legendary');
                    console.log(`Paused ${selectedPlayer.name} until:`, new Date(selectedPlayer.pausedUntil));
                    
                    // Save pause status to Firebase so all players see it IMMEDIATELY
                    try {
                        const pauseGameState = {
                            players: game.players.map(p => ({
                                name: p.name,
                                hand: p.hand,
                                isDisqualified: p.isDisqualified,
                                hasFinished: p.hasFinished,
                                isPaused: p.isPaused,
                                pausedUntil: p.pausedUntil
                            })),
                            deck: game.deck,
                            discardPile: game.discardPile,
                            currentPlayerIndex: game.currentPlayerIndex,
                            roundNumber: game.roundNumber,
                            direction: game.direction,
                            lastMoveBy: gameSession.playerName,
                            timestamp: Date.now()
                        };
                        
                        const response = await fetch(`${FIREBASE_URL}/games/${gameSession.pin}/gameState.json`, {
                            method: 'PUT',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify(pauseGameState)
                        });
                        
                        if (response.ok) {
                            console.log('‚úÖ Pause status saved to Firebase immediately');
                        }
                    } catch (error) {
                        console.error('‚ùå Failed to save pause to Firebase:', error);
                    }
                    
                    // Dramatic effect for the paused player
                    if (selectedPlayer.name === gameSession.playerName) {
                        triggerVibration([300, 500]); // Strong pause effect
                        showMessage('‚è∏Ô∏è Time has stopped for you! You must wait 5 minutes!', 'warning');
                    }
                    
                    // Start a timer to unpause the player
                    setTimeout(async () => {
                        if (selectedPlayer.isPaused) {
                            selectedPlayer.isPaused = false;
                            selectedPlayer.pausedUntil = 0;
                            showMessage(`‚èØÔ∏è Time flows once again for ${selectedPlayer.name}!`, 'special');
                            console.log(`Unpaused ${selectedPlayer.name}`);
                            
                            // Save unpause status to Firebase
                            try {
                                const unpauseGameState = {
                                    players: game.players.map(p => ({
                                        name: p.name,
                                        hand: p.hand,
                                        isDisqualified: p.isDisqualified,
                                        hasFinished: p.hasFinished,
                                        isPaused: p.isPaused,
                                        pausedUntil: p.pausedUntil
                                    })),
                                    deck: game.deck,
                                    discardPile: game.discardPile,
                                    currentPlayerIndex: game.currentPlayerIndex,
                                    roundNumber: game.roundNumber,
                                    direction: game.direction,
                                    lastMoveBy: gameSession.playerName,
                                    timestamp: Date.now()
                                };
                                
                                const response = await fetch(`${FIREBASE_URL}/games/${gameSession.pin}/gameState.json`, {
                                    method: 'PUT',
                                    headers: {'Content-Type': 'application/json'},
                                    body: JSON.stringify(unpauseGameState)
                                });
                                
                                if (response.ok) {
                                    console.log('‚úÖ Unpause status saved to Firebase');
                                }
                            } catch (error) {
                                console.error('‚ùå Failed to save unpause to Firebase:', error);
                            }
                            
                            updateDisplay();
                        }
                    }, 5 * 60 * 1000);
                }
            });
        }
        
        // Helper function to show player selection dialog
        function showPlayerSelectionDialog(players, callback) {
            const dialog = document.createElement('div');
            dialog.className = 'modal';
            dialog.style.display = 'block';
            
            const content = document.createElement('div');
            content.className = 'modal-content';
            content.innerHTML = '<h2>üéØ Choose a player to pause</h2>';
            
            players.forEach(player => {
                const button = document.createElement('button');
                button.className = 'player-select-btn';
                button.textContent = player.name;
                button.onclick = () => {
                    dialog.remove();
                    callback(player);
                };
                content.appendChild(button);
            });
            
            dialog.appendChild(content);
            document.body.appendChild(dialog);
        }

        function getNextActivePlayer() {
            const startIndex = (game.currentPlayerIndex + game.direction + game.players.length) % game.players.length;
            for (let i = 0; i < game.players.length; i++) {
                const playerIndex = (startIndex + (i * game.direction) + game.players.length) % game.players.length;
                console.log('Checking player index:', playerIndex);
                if (game.players[playerIndex].isActive()) {
                    return game.players[playerIndex];
                }
            }
            return null;
        }

        async function nextTurn() {
            const originalIndex = game.currentPlayerIndex;
            const previousPlayer = game.players[game.currentPlayerIndex];
            console.log('‚è≠Ô∏è Moving from player:', previousPlayer.name);
            console.log('üß≠ Direction:', game.direction === 1 ? 'clockwise' : 'counter-clockwise');
            
            // Add visual feedback for turn change
            showMessage(`${previousPlayer.name}'s turn has ended`, 'info');
            
            for (let i = 0; i < game.players.length; i++) {
                game.currentPlayerIndex = (game.currentPlayerIndex + game.direction + game.players.length) % game.players.length;
                const currentPlayer = game.players[game.currentPlayerIndex];
                if (currentPlayer.canTakeTurn()) {
                    break;
                } else if (currentPlayer.isActive() && currentPlayer.isPaused) {
                    // Skip paused player but show message
                    const remainingTime = Math.ceil((currentPlayer.pausedUntil - Date.now()) / 1000);
                    if (remainingTime > 0) {
                        showMessage(`‚è∏Ô∏è ${currentPlayer.name} is paused for ${remainingTime} more seconds`, 'info');
                    }
                }
            }

            const nextPlayer = game.players[game.currentPlayerIndex];
            console.log('‚è≠Ô∏è Next player is:', nextPlayer.name);
            
            // Show turn change message with visual feedback
            showMessage(`üéÆ It's ${nextPlayer.name}'s turn!`, 'success');
            
            // Play sound effect for the next player
            if (nextPlayer.name === gameSession.playerName) {
                audioManager?.playSound('buttonClick', 0.5);
                // Add vibration feedback if supported
                if ('vibrate' in navigator) {
                    navigator.vibrate(200);
                }
            }
            
            // Play button click sound for turn notification (turnNotification file not available)
            const currentPlayer = game.players[game.currentPlayerIndex];
            if (currentPlayer && currentPlayer.name === gameSession.playerName) {
                audioManager?.playSound('buttonClick', 0.3);
            }

            // Check if we completed a round (more complex with direction changes)
            const roundCompleted = (game.direction === 1 && game.currentPlayerIndex <= originalIndex) ||
                                 (game.direction === -1 && game.currentPlayerIndex >= originalIndex);
            
            if (roundCompleted) {
                game.roundNumber++;
                game.highCardPlayedThisRound = false;
                showMessage(`üîÑ Round ${game.roundNumber}`, 'info');
                console.log('üîÑ New round started:', game.roundNumber);
            }
        }

        async function drawCard() {
            console.log('üÉè Draw card function called');
            
            // Check if it's this player's turn
            const currentPlayer = game.players[game.currentPlayerIndex];
            if (currentPlayer.name !== gameSession.playerName) {
                showMessage("It's not your turn! Wait for your turn to draw.", 'error');
                audioManager?.playSound('loseSound', 0.3);
                return false;
            }
            
            console.log('üë§ Current player:', currentPlayer.name);
            console.log('üì¶ Cards in deck before draw:', game.deck.length);
            console.log('üé¥ Player hand size before draw:', currentPlayer.hand.length);
            
            // CRITICAL: Refill deck from discard pile if deck is empty
            if (game.deck.length === 0) {
                if (game.discardPile.length > 0) {
                    // Take all but the top card from discard pile and make it the new deck
                    const topCard = game.discardPile[game.discardPile.length - 1];
                    game.deck = game.discardPile.slice(0, -1); // All cards except the last one
                    game.discardPile = [topCard]; // Keep only the top card
                    game.deck = shuffleDeck(game.deck);
                    showMessage(`üîÑ Deck refilled with ${game.deck.length} cards from discard pile!`, 'info');
                    console.log(`üîÑ Deck refilled: ${game.deck.length} cards from discard pile`);
                } else {
                    // No cards anywhere - game cannot continue
                    showMessage("No cards left in deck or discard pile! Game cannot continue.", 'error');
                    audioManager?.playSound('loseSound', 0.3);
                    console.log('‚ùå No cards left anywhere');
                    return false;
                }
            }

            const card = game.deck.pop();
            console.log('üéØ Drew card:', card.toString());
            
            // Play draw sound
            audioManager?.playSound('cardFlip');
            
            currentPlayer.addCard(card);
            console.log('‚úÖ Card added to player hand');
            console.log('üé¥ Player hand size after draw:', currentPlayer.hand.length);
            console.log('üì¶ Cards in deck after draw:', game.deck.length);
            
            showMessage(`${currentPlayer.name} drew a card: ${card}`, 'info');

            if (currentPlayer.isDisqualified) {
                showMessage(`${currentPlayer.name} is disqualified for having over 20 cards!`, 'error');
                console.log('‚ùå Player disqualified');
            }

            // Move to next player
            await nextTurn();
            
            // Save game state to Firebase
            await saveGameStateToCloud(gameSession.pin, {
                players: game.players.map(p => ({
                    name: p.name,
                    hand: p.hand,
                    active: p.active,
                    isDisqualified: p.isDisqualified,
                    hasFinished: p.hasFinished,
                    isPaused: p.isPaused,
                    pausedUntil: p.pausedUntil
                })),
                deck: game.deck,
                discardPile: game.discardPile,
                currentPlayerIndex: game.currentPlayerIndex,
                roundNumber: game.roundNumber,
                highCardPlayedThisRound: game.highCardPlayedThisRound,
                gameOver: game.gameOver,
                winner: game.winner,
                direction: game.direction,
                timestamp: Date.now(),
                lastMoveBy: gameSession.playerName
            });
            
            // Update display immediately
            console.log('üîÑ Updating display after draw...');
            updateDisplay();
            console.log('‚úÖ Draw card completed');
            
            return true;
        }

        async function checkGameOver() {
            // Don't check if game is already over
            if (game.gameOver) {
                console.log('üîç checkGameOver called but game.gameOver is already true');
                return;
            }

            const activePlayers = game.players.filter(p => p.isActive());
            const finishedPlayers = game.players.filter(p => p.hasFinished);

            console.log('üîç checkGameOver - Active:', activePlayers.length, 'Finished:', finishedPlayers.length, 'Total:', game.players.length);

            if (finishedPlayers.length > 0) {
                console.log('üèÜ Game Over - Finished players found:', finishedPlayers.map(p => p.name));
                game.gameOver = true;
                game.winner = finishedPlayers[0];
                
                // Play win/lose sound based on if current player won
                if (game.winner.name === gameSession.playerName) {
                    audioManager?.playSound('winSound');
                } else {
                    audioManager?.playSound('loseSound');
                }
                
                showGameOver(`üéâ ${game.winner.name} wins!`);
                
                // Save final game state to Firebase so all players see the winner
                if (gameSession.pin) {
                    await saveGameStateToCloud(gameSession.pin, {
                        players: game.players.map(p => ({
                            name: p.name,
                            hand: p.hand,
                            isDisqualified: p.isDisqualified,
                            hasFinished: p.hasFinished,
                            isPaused: p.isPaused,
                            pausedUntil: p.pausedUntil
                        })),
                        deck: game.deck,
                        discardPile: game.discardPile,
                        currentPlayerIndex: game.currentPlayerIndex,
                        roundNumber: game.roundNumber,
                        highCardPlayedThisRound: game.highCardPlayedThisRound,
                        gameOver: game.gameOver,
                        winner: game.winner ? {name: game.winner.name} : null,
                        direction: game.direction,
                        lastMoveBy: gameSession.playerName,
                        timestamp: Date.now()
                    });
                }
            } else if (activePlayers.length <= 1) {
                console.log('‚ö†Ô∏è  Game Over - activePlayers.length <= 1:', activePlayers.length);
                console.log('   Active players:', activePlayers.map(p => p.name));
                console.log('   All players:', game.players.map(p => `${p.name}(disq=${p.isDisqualified},fin=${p.hasFinished})`));
                game.gameOver = true;
                if (activePlayers.length === 1) {
                    game.winner = activePlayers[0];
                    showGameOver(`üéâ ${game.winner.name} wins!`);
                } else {
                    game.winner = null;
                    console.log('‚ùå Showing "no winner" message - this is the bug!');
                    showGameOver("üòû Game ended with no winner.");
                }
                
                // Save final game state to Firebase so all players see the result
                if (gameSession.pin) {
                    await saveGameStateToCloud(gameSession.pin, {
                        players: game.players.map(p => ({
                            name: p.name,
                            hand: p.hand,
                            isDisqualified: p.isDisqualified,
                            hasFinished: p.hasFinished,
                            isPaused: p.isPaused,
                            pausedUntil: p.pausedUntil
                        })),
                        deck: game.deck,
                        discardPile: game.discardPile,
                        currentPlayerIndex: game.currentPlayerIndex,
                        roundNumber: game.roundNumber,
                        highCardPlayedThisRound: game.highCardPlayedThisRound,
                        gameOver: game.gameOver,
                        winner: game.winner ? {name: game.winner.name} : null,
                        direction: game.direction,
                        lastMoveBy: gameSession.playerName,
                        timestamp: Date.now()
                    });
                }
            }
        }

        function showGameOver(message) {
            document.getElementById('gameOverTitle').textContent = 'Game Over!';
            document.getElementById('gameOverMessage').textContent = message;
            
            // Show/hide buttons based on host status
            const playAgainBtn = document.getElementById('playAgainBtn');
            const leaveGameBtn = document.getElementById('leaveGameBtn');
            const endGameBtn = document.getElementById('endGameBtn');
            
            if (gameSession.isHost) {
                // Host sees: Play Again and End Game buttons
                playAgainBtn.style.display = 'block';
                leaveGameBtn.style.display = 'none';
                endGameBtn.style.display = 'block';
            } else {
                // Players see: Play Again and Leave Game buttons
                playAgainBtn.style.display = 'block';
                leaveGameBtn.style.display = 'block';
                endGameBtn.style.display = 'none';
            }
            
            document.getElementById('gameOverModal').style.display = 'block';
        }

        function showMessage(message, type = 'info') {
            const messagesContainer = document.getElementById('gameMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `game-message message-${type}`;
            messageDiv.textContent = message;
            messagesContainer.appendChild(messageDiv);
            
            // Remove old messages
            const messages = messagesContainer.children;
            if (messages.length > 3) {
                messagesContainer.removeChild(messages[0]);
            }
            
            // Auto-remove message after 5 seconds
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.parentNode.removeChild(messageDiv);
                }
            }, 5000);
        }

        async function updateDisplay() {
                // Update game info
            document.getElementById('roundNumber').textContent = game.roundNumber;
            document.getElementById('deckCount').textContent = game.deck.length;
            
            // Ensure highCardPlayedThisRound is always boolean
            const hasHighCard = game.highCardPlayedThisRound === true;
            document.getElementById('highCardPlayed').textContent = hasHighCard ? '‚úÖ' : '‚ùå';
            
            // Update current player with highlight effect
            const currentPlayerElement = document.getElementById('currentPlayer');
            currentPlayerElement.textContent = game.players[game.currentPlayerIndex]?.name || '-';
            currentPlayerElement.classList.remove('player-turn-highlight');
            void currentPlayerElement.offsetWidth; // Trigger reflow
            currentPlayerElement.classList.add('player-turn-highlight');
            
            document.getElementById('gameDirection').textContent = game.direction === 1 ? '‚Üª Clockwise' : '‚Ü∫ Counter-CW';

            // Update discard pile display
            const lastCardElement = document.getElementById('lastPlayedCard');
            lastCardElement.innerHTML = '';

            if (game.discardPile && game.discardPile.length > 0) {
                // Show up to 3 most recently played cards with a stacked effect
                const startIndex = Math.max(0, game.discardPile.length - 3);
                const recentCards = game.discardPile.slice(startIndex);
                
                const stackContainer = document.createElement('div');
                stackContainer.className = 'card-stack';
                stackContainer.style.position = 'relative';
                stackContainer.style.height = '150px';
                stackContainer.style.width = '100px';
                stackContainer.style.margin = '0 auto';
                
                recentCards.forEach((card, index) => {
                    const cardElement = createCardElement(card, -1, -1, true);
                    cardElement.style.position = 'absolute';
                    cardElement.style.left = `${index * 5}px`;
                    cardElement.style.top = `${index * 5}px`;
                    cardElement.style.zIndex = index;
                    
                    // Add highlight effect to the most recently played card
                    if (index === recentCards.length - 1) {
                        cardElement.classList.add('last-played-highlight');
                    }
                    
                    stackContainer.appendChild(cardElement);
                });
                
                lastCardElement.appendChild(stackContainer);
                console.log('Updated discard pile display with', recentCards.length, 'cards');
            } else {
                lastCardElement.innerHTML = '<div class="card regular" style="margin: 0 auto; background: #ddd; color: #666;">No Card Yet</div>';
            }

            // Update players
            updatePlayersDisplay();

            // Update draw button - only enable for current player's turn
            const drawBtn = document.getElementById('drawBtn');
            const isMyTurn = game.players[game.currentPlayerIndex]?.name === gameSession.playerName;
            const shouldDisableDrawBtn = game.deck.length === 0 || game.gameOver || !isMyTurn;
            drawBtn.disabled = shouldDisableDrawBtn;
            console.log('üÉè Draw button status:', shouldDisableDrawBtn ? 'disabled' : 'enabled', '(deck:', game.deck.length, 'cards, gameOver:', game.gameOver, 'myTurn:', isMyTurn, ')');

            // Update game action button (New Game for host, Leave Game for non-host)
            const gameActionBtn = document.getElementById('gameActionBtn');
            if (gameSession.isHost) {
                if (game.gameOver) {
                    gameActionBtn.textContent = 'üéÆ NEW GAME';
                    gameActionBtn.className = 'btn draw'; // Green button
                } else {
                    gameActionBtn.textContent = 'üõë END GAME';
                    gameActionBtn.className = 'btn quit'; // Red button
                }
            } else {
                gameActionBtn.textContent = 'üö™ LEAVE GAME';
                gameActionBtn.className = 'btn quit'; // Red button
            }

            // Check for game over (but skip on first call during initialization)
            if (!game.gameOver && gameInitializationComplete) {
                await checkGameOver();
            }
        }

        function updatePlayersDisplay() {
            const container = document.getElementById('playersContainer');
            container.innerHTML = '';

            const avatarIcons = ['üë§', 'üé≠', 'ü§ñ', 'üëæ'];
            const avatarColors = [
                'linear-gradient(135deg, #ff9a9e, #fecfef)',
                'linear-gradient(135deg, #a8edea, #fed6e3)', 
                'linear-gradient(135deg, #fbc2eb, #a6c1ee)',
                'linear-gradient(135deg, #74b9ff, #0984e3)'
            ];

            game.players.forEach((player, playerIndex) => {
                const seatDiv = document.createElement('div');
                seatDiv.className = 'player-seat';
                
                const avatarDiv = document.createElement('div');
                avatarDiv.className = 'player-avatar';
                
                if (playerIndex === game.currentPlayerIndex && player.isActive()) {
                    avatarDiv.classList.add('current-turn');
                }
                if (player.isDisqualified) {
                    avatarDiv.classList.add('disqualified');
                }
                if (player.hasFinished) {
                    avatarDiv.classList.add('finished');
                }

                // Create avatar icon
                const iconDiv = document.createElement('div');
                iconDiv.className = 'avatar-icon';
                iconDiv.style.background = avatarColors[playerIndex];
                iconDiv.textContent = avatarIcons[playerIndex];

                // Create player name
                const nameDiv = document.createElement('div');
                nameDiv.className = 'player-name';
                nameDiv.textContent = player.name;

                // Create card count
                const cardCountDiv = document.createElement('div');
                cardCountDiv.className = 'card-count';
                cardCountDiv.textContent = `${player.hand.length} cards`;

                // Create status indicator
                let statusText = '';
                if (player.hasFinished) {
                    statusText = 'üèÜ Winner!';
                    cardCountDiv.style.color = '#FFD700';
                } else if (player.isDisqualified) {
                    statusText = '‚ùå Out';
                    cardCountDiv.style.color = '#f44336';
                } else if (player.isPaused && Date.now() < player.pausedUntil) {
                    const remainingTime = Math.ceil((player.pausedUntil - Date.now()) / 1000);
                    statusText = `‚è∏Ô∏è Paused (${remainingTime}s)`;
                    cardCountDiv.style.color = '#ff9800';
                } else if (playerIndex === game.currentPlayerIndex) {
                    statusText = '‚≠ê Turn';
                    cardCountDiv.style.color = '#4CAF50';
                } else {
                    cardCountDiv.style.color = '#666';
                }

                if (statusText) {
                    const statusDiv = document.createElement('div');
                    statusDiv.style.fontSize = '0.8em';
                    statusDiv.style.fontWeight = 'bold';
                    statusDiv.style.marginTop = '3px';
                    statusDiv.textContent = statusText;
                    avatarDiv.appendChild(statusDiv);
                }

                // Create simplified hand display (just show a few cards as indicators)
                const handDiv = document.createElement('div');
                handDiv.className = 'player-hand';
                handDiv.id = `player-${playerIndex}-hand`;

                const lastCard = game.discardPile[game.discardPile.length - 1];
                
                // Show cards based on whether this is the logged-in player's own hand
                const isOwnHand = (player.name === gameSession.playerName);
                
                // Mark if this is the own hand for special styling
                if (isOwnHand) {
                    handDiv.classList.add('own-hand');
                }
                const cardsToShow = isOwnHand ? player.hand : player.hand.slice(0, 3);
                
                cardsToShow.forEach((card, cardIndex) => {
                    // Cards are only playable if it's your own hand AND it's your turn
                    const isPlayable = isOwnHand && playerIndex === game.currentPlayerIndex && game.players && game.players[playerIndex];
                    const displayCard = isOwnHand ? card : createCardBack();
                    const cardElement = createCardElement(displayCard, playerIndex, cardIndex, false, isPlayable, !isOwnHand);
                    handDiv.appendChild(cardElement);
                });

                // If player has more than 3 cards and it's not own hand, show "..."
                if (!isOwnHand && player.hand.length > 3) {
                    const moreDiv = document.createElement('div');
                    moreDiv.style.fontSize = '0.8em';
                    moreDiv.style.color = '#666';
                    moreDiv.style.alignSelf = 'center';
                    moreDiv.textContent = '...';
                    handDiv.appendChild(moreDiv);
                }

                // Assemble avatar
                avatarDiv.appendChild(iconDiv);
                avatarDiv.appendChild(nameDiv);
                avatarDiv.appendChild(cardCountDiv);
                // Always show cards - either own cards (face up) or card backs (face down)
                avatarDiv.appendChild(handDiv);

                seatDiv.appendChild(avatarDiv);
                container.appendChild(seatDiv);
            });
            
            console.log('Players display updated - circular table layout');
        }

        function createCardBack() {
            // Create a card back object for other players' hidden cards
            return {
                value: 0,
                type: 'back',
                toString: () => 'üÇ†',
                isPeakCard: () => false,
                isReverseCard: () => false,
                canFinishOn: () => false
            };
        }

        function createCardElement(card, playerIndex, cardIndex, isLastPlayed = false, isPlayable = false, isCardBack = false) {
            const cardDiv = document.createElement('div');
            
            if (isCardBack) {
                cardDiv.className = 'card card-back';
                cardDiv.textContent = 'üÇ†';
                cardDiv.style.background = 'linear-gradient(145deg, #1a1a1a, #333)';
                cardDiv.style.color = '#666';
                cardDiv.style.cursor = 'default';
            } else {
                cardDiv.className = 'card ' + card.type;
                cardDiv.textContent = card.toString();
                
                if (isLastPlayed) {
                    cardDiv.classList.add('last-played');
                }
                if (isPlayable) {
                    cardDiv.classList.add('playable');
                    cardDiv.onclick = async () => {
                        await playCard(playerIndex, cardIndex);
                    };
                    cardDiv.style.cursor = 'pointer';
                }
            }
            
            return cardDiv;
        }

        async function createGame() {
            audioManager?.playSound('buttonClick');
            const playerName = document.getElementById('playerName').value.trim();
            if (!playerName) {
                alert('Please enter your name');
                return;
            }

            // Show player count selection
            const playerCountSection = document.getElementById('playerCountSection');
            const gameCreationControls = document.getElementById('gameCreationControls');
            if (playerCountSection.style.display === 'none' || !playerCountSection.style.display) {
                playerCountSection.style.display = 'block';
                gameCreationControls.style.display = 'block';
                
                // Re-initialize button handlers after showing
                setTimeout(() => {
                    initPlayerCountButtons();
                }, 100);
                
                // Auto-select 4 players by default if nothing selected yet
                if (!document.querySelector('.player-count-btn.selected')) {
                    selectPlayerCount(4);
                }
                // Change button text to indicate next step
                const createBtn = document.getElementById('createGameBtn');
                createBtn.textContent = 'üöÄ Create Game with Selected Players';
                return; // Don't create game yet, wait for player count selection
            }

            // If we get here, player count has been selected, so create the actual game
            // Generate 4-digit PIN and store it in a variable to ensure consistency
            const pin = Math.floor(1000 + Math.random() * 9000).toString();
            console.log('üé≤ Generated new game PIN:', pin);
            
            const hostPlayer = {
                id: generatePlayerId(),
                name: playerName,
                isHost: true
            };
            
            // Initialize lobbyPlayers as an object with player ID as key
            const lobbyPlayersObj = {};
            lobbyPlayersObj[hostPlayer.id] = hostPlayer;
            
            gameSession = {
                pin: pin,
                isHost: true,
                playerName: playerName,
                playerId: hostPlayer.id,
                lobbyPlayers: lobbyPlayersObj,  // Use object from the start!
                gameStarted: false,
                maxPlayers: selectedPlayerCount
            };

            // Try to save to Firebase with retry logic
            console.log('üíæ Saving game to Firebase with PIN:', pin);
            let saveSuccess = false;
            let attempts = 0;
            const maxAttempts = 3;

            while (!saveSuccess && attempts < maxAttempts) {
                attempts++;
                if (attempts > 1) {
                    console.log(`Retry attempt ${attempts}/${maxAttempts}...`);
                }

                // lobbyPlayers is already an object, so use it directly
                const gameDataToSave = {
                    pin: pin,  // Ensure we use the same PIN
                    lobbyPlayers: gameSession.lobbyPlayers,  // Already an object!
                    gameStarted: false,
                    maxPlayers: selectedPlayerCount,
                    createdAt: firebase.database.ServerValue.TIMESTAMP
                };
                console.log('üì¶ Game data being saved:', gameDataToSave);
                saveSuccess = await saveGameToCloud(pin, gameDataToSave);
                
                if (!saveSuccess && attempts < maxAttempts) {
                    // Wait before retrying
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }
            
            if (!saveSuccess) {
                alert('Failed to create game. Please check your internet connection and try again.');
                return;
            }
            console.log('‚úÖ Game successfully saved to Firebase');

            showLobby();
            startRealTimeListener(pin); // Start real-time updates
            console.log('Game created with PIN:', pin);
        }

        async function joinGame() {
            try {
                console.log('Join game function called');
                const joinBtn = document.getElementById('joinBtn');
                joinBtn.disabled = true; // Disable to prevent double-clicks
                
                const playerName = document.getElementById('playerName').value.trim();
                const pin = document.getElementById('gamePin').value.trim();
                
                console.log('Attempting to join with name:', playerName, 'and PIN:', pin);
                
                if (!playerName) {
                    alert('Please enter your name');
                    joinBtn.disabled = false;
                    return;
                }
                
                if (!pin || pin.length !== 4 || !/^\d{4}$/.test(pin)) {
                    alert('Please enter a valid 4-digit PIN');
                    joinBtn.disabled = false;
                    return;
                }

                // Check if game session exists in cloud
                console.log('üîç Looking for game with PIN:', pin);
                const sessionData = await loadGameFromCloud(pin);
                if (!sessionData) {
                    alert('Game not found! Please check the PIN and make sure the host has created the game.');
                    console.log('‚ùå No game found for PIN:', pin);
                    joinBtn.disabled = false;
                    return;
                }
                console.log('‚úÖ Found game session:', sessionData);
            
            // Always treat lobbyPlayers as an object
            const currentPlayers = sessionData.lobbyPlayers || {};
            const playerCount = Object.keys(currentPlayers).length;
            console.log('üë• Current players:', currentPlayers);

            // Check if game is full
            const maxPlayers = sessionData.maxPlayers || 4;
            if (playerCount >= maxPlayers) {
                alert(`Game is full! Maximum ${maxPlayers} players allowed.`);
                joinBtn.disabled = false;
                return;
            }

            // Check if player name already exists in the object
            if (Object.values(currentPlayers).some(p => p && p.name === playerName)) {
                alert('Player name already taken! Please choose a different name.');
                joinBtn.disabled = false;
                return;
            }

            // Create new player
            const newPlayerId = generatePlayerId();
            const newPlayer = {
                id: newPlayerId,
                name: playerName,
                isHost: false
            };
            
            // Initialize lobbyPlayers as object if it doesn't exist
            if (!sessionData.lobbyPlayers || Array.isArray(sessionData.lobbyPlayers)) {
                sessionData.lobbyPlayers = {};
            }
            
            // Add new player using their ID as the key
            sessionData.lobbyPlayers[newPlayerId] = newPlayer;
            
            try {
                // Update cloud using Firebase's real-time database directly
                const gameRef = firebase.database().ref(`games/${pin}`);
                await gameRef.update({
                    [`lobbyPlayers/${newPlayerId}`]: newPlayer,
                    lastUpdate: firebase.database.ServerValue.TIMESTAMP
                });

                // Set up local game session
                gameSession = {
                    pin: pin,
                    isHost: false,
                    playerName: playerName,
                    playerId: newPlayer.id,
                    lobbyPlayers: sessionData.lobbyPlayers,
                    gameStarted: false,
                    maxPlayers: sessionData.maxPlayers || 4
                };

                // Hide setup screens
                document.getElementById('startScreen').style.display = 'none';
                
                // Update game PIN in lobby
                document.getElementById('gamePinDisplay').textContent = `Game PIN: ${pin}`;
                
                // Show lobby screen
                document.getElementById('lobbyScreen').style.display = 'block';
                
                // Start real-time updates and show lobby
                const lobbyRef = firebase.database().ref(`games/${pin}`);
                lobbyRef.on('value', (snapshot) => {
                    const data = snapshot.val();
                    if (data && data.lobbyPlayers) {
                        gameSession.lobbyPlayers = data.lobbyPlayers;
                        const playersUL = document.getElementById('playersUL');
                        if (playersUL) {
                            playersUL.innerHTML = '';
                            Object.values(data.lobbyPlayers).forEach(player => {
                                const li = document.createElement('li');
                                li.style.padding = '10px';
                                li.style.marginBottom = '5px';
                                li.style.backgroundColor = 'rgba(255,255,255,0.9)';
                                li.style.borderRadius = '5px';
                                li.innerHTML = `${player.name} ${player.isHost ? '(Host)' : '(Player)'}`;
                                playersUL.appendChild(li);
                            });
                        }
                    }
                });
                
                console.log('Successfully joined lobby for game:', pin);
                audioManager?.playSound('buttonClick');
                joinBtn.disabled = false;
            } catch (error) {
                console.error('Error joining lobby:', error);
                joinBtn.disabled = false;
                alert('Error joining game. Please try again.');
            }

            console.log('Transitioning to lobby screen...');
            
            // First, set up the game session and start listener
            await startRealTimeListener(pin);
            
            // Show the lobby screen (don't hide setupModal since lobby is inside it)
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('lobbyScreen').style.display = 'block';
            
            // Update game PIN display
            document.getElementById('gamePinDisplay').textContent = `Game PIN: ${pin}`;
            
            // Update the lobby display
            showLobby();
            
            console.log('Successfully joined game lobby');
            audioManager?.playSound('buttonClick');
            
            joinBtn.disabled = false; // Re-enable the button
        } catch (error) {
            console.error('Error joining game:', error);
            alert('Failed to join game. Please try again.');
            document.getElementById('joinBtn').disabled = false;
        }
        }

        function generatePlayerId() {
            return 'player_' + Math.random().toString(36).substr(2, 9);
        }



        function showLobby() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('lobbyScreen').style.display = 'block';
            document.getElementById('gamePinDisplay').textContent = `PIN: ${gameSession.pin}`;
            
            // Show player count information
            const maxPlayers = gameSession.maxPlayers || 4;
            const playerEmojis = {2: 'üë•', 3: 'üë®‚Äçüë©‚Äçüëß', 4: 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶'};
            document.getElementById('playerCountDisplay').innerHTML = `${playerEmojis[maxPlayers] || 'üë•'} ${maxPlayers} Player Game`;
            
            // Update shareable link
            const shareUrl = generateShareableLink(gameSession.pin);
            document.getElementById('shareUrl').textContent = shareUrl;
            
            updateLobbyDisplay();
        }

        function updateLobbyDisplay() {
            if (!gameSession) {
                console.error('‚ùå No game session found');
                return;
            }

            const playersList = document.getElementById('playersUL');
            if (!playersList) {
                console.error('‚ùå Could not find players list element');
                return;
            }

            console.log('üîÑ Updating lobby display...');
            console.log('Current game session:', gameSession);
            console.log('Lobby players data:', gameSession.lobbyPlayers);

            // Clear existing player list
            playersList.innerHTML = '';

            // Get all players from Firebase data and ensure we're using the latest data
            const players = gameSession.lobbyPlayers || {};
            // Filter out any null/undefined entries and convert to array
            const playersArray = Object.entries(players)
                .filter(([_, player]) => player) // Remove any null/undefined entries
                .map(([id, player]) => ({...player, id})); // Convert to array with IDs

            // Sort players so host is always first
            playersArray.sort((a, b) => {
                if (a.isHost) return -1;
                if (b.isHost) return 1;
                return 0;
            });

            // Add each player to the list with consistent formatting
            playersArray.forEach(player => {
                console.log('Adding player to display:', player);
                
                const li = document.createElement('li');
                li.style.padding = '10px';
                li.style.marginBottom = '5px';
                li.style.backgroundColor = 'rgba(255,255,255,0.9)';
                li.style.borderRadius = '5px';
                li.style.display = 'flex';
                li.style.alignItems = 'center';
                li.style.justifyContent = 'space-between';
                
                // Show crown for host, player icon for others
                const icon = player.isHost ? 'üëë' : 'üë§';
                
                // Show (You) for current player
                const isCurrentPlayer = player.id === gameSession.playerId;
                const displayName = `${icon} ${player.name} ${isCurrentPlayer ? '(You)' : ''}`;
                
                // Create the player entry with name and ready status
                li.innerHTML = `
                    <span style="font-size: 1.1em; font-weight: ${player.isHost ? 'bold' : 'normal'}">
                        ${displayName}
                    </span>
                `;
                
                // Add to the list
                playersList.appendChild(li);
                console.log('Added player to display:', displayName);
                
                li.textContent = displayName;
                playersList.appendChild(li);
            });

            // Update the ready/waiting message
            const readyMessage = document.getElementById('readyMessage');
            if (readyMessage) {
                const totalPlayers = playersArray.length;
                readyMessage.textContent = `Ready to start! (${totalPlayers} players)`;
            }

            // Set up real-time listener for lobby updates if not already set
            if (gameSession.pin && !gameUpdateListener) {
                const gameRef = firebase.database().ref(`games/${gameSession.pin}`);
                gameUpdateListener = gameRef.on('value', (snapshot) => {
                    const gameData = snapshot.val();
                    if (gameData && gameData.players) {
                        gameSession.players = gameData.players;
                        // Force a UI refresh, but prevent infinite recursion
                        if (document.getElementById('playersUL')) {
                            renderLobbyPlayers();
                        }
                    }
                });
            }

            const playersUL = document.getElementById('playersUL');
            if (!playersUL) {
                return;
            }
            
            renderLobbyPlayers();
        }
        
        function renderLobbyPlayers() {
            const playersUL = document.getElementById('playersUL');
            if (!playersUL) {
                console.error('‚ùå Players list element not found');
                return;
            }

            playersUL.innerHTML = '';
            
            // Convert players object to array if necessary
            let playersArray = [];
            if (gameSession.lobbyPlayers) {
                if (Array.isArray(gameSession.lobbyPlayers)) {
                    playersArray = gameSession.lobbyPlayers;
                } else if (typeof gameSession.lobbyPlayers === 'object') {
                    playersArray = Object.values(gameSession.lobbyPlayers).filter(Boolean);
                }
            }
            
            console.log('üîÑ Updating lobby display with players:', playersArray);
            
            if (playersArray.length === 0) {
                const li = document.createElement('li');
                li.style.padding = '5px 0';
                li.innerHTML = '<em>Waiting for players to join...</em>';
                playersUL.appendChild(li);
                return;
            }

            playersArray.forEach(player => {
                if (!player || !player.name) {
                    console.log('‚ö†Ô∏è Skipping invalid player:', player);
                    return;
                }
                const li = document.createElement('li');
                li.style.padding = '5px 0';
                li.style.marginBottom = '5px';
                li.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
                li.style.borderRadius = '4px';
                li.style.padding = '8px';
                li.innerHTML = `
                    <span style="display: inline-block; width: 20px;">${player.isHost ? 'üëë' : 'üë§'}</span>
                    <strong>${player.name}</strong>
                    ${player.id === gameSession.playerId ? ' <span style="color: #4CAF50">(You)</span>' : ''}
                `;
                playersUL.appendChild(li);
            });

            // Update start button (only host can start, and need required players)
            const startBtn = document.getElementById('startGameBtn');
            const maxPlayers = gameSession.maxPlayers || 4;
            const canStart = gameSession.isHost && playersArray.length === maxPlayers;
            startBtn.disabled = !canStart;
            
            const waitingMsg = document.getElementById('waitingMessage');
            if (gameSession.lobbyPlayers.length < maxPlayers) {
                waitingMsg.textContent = `Waiting for ${maxPlayers - gameSession.lobbyPlayers.length} more players... (${gameSession.lobbyPlayers.length}/${maxPlayers})`;
            } else if (!gameSession.isHost) {
                waitingMsg.textContent = 'Waiting for host to start the game...';
            } else {
                waitingMsg.textContent = `Ready to start! (${maxPlayers} players)`;
            }
        }

        let lobbyPollingInterval = null;

        function startLobbyPolling() {
            // This function is now replaced by startRealTimeListener
            // Keeping for compatibility but redirecting to new function
            console.log('‚ö†Ô∏è startLobbyPolling is deprecated, using startRealTimeListener instead');
            startRealTimeListener(gameSession.pin);
        }

        function stopLobbyPolling() {
            // This function is now replaced by stopRealTimeListener
            console.log('‚ö†Ô∏è stopLobbyPolling is deprecated, using stopRealTimeListener instead');
            stopRealTimeListener();
            if (lobbyPollingInterval) {
                clearInterval(lobbyPollingInterval);
                lobbyPollingInterval = null;
            }
        }

        async function leaveLobby() {
            // Stop real-time updates
            stopRealTimeListener();
            
            // If host is leaving, clean up the game session
            if (gameSession.isHost && gameSession.pin) {
                await removeGameFromCloud(gameSession.pin);
            }
            
            document.getElementById('lobbyScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'block';
            
            // Clear fields
            document.getElementById('playerName').value = '';
            document.getElementById('gamePin').value = '';
            
            gameSession = {
                pin: null,
                isHost: false,
                playerName: '',
                playerId: null,
                lobbyPlayers: [],
                gameStarted: false
            };
        }

        // Handle game start for non-host players receiving the gameStarted flag
        async function handleGameStart() {
            console.log('üéÆ handleGameStart() called for non-host player');
            console.log('Player name:', gameSession.playerName);
            console.log('PIN:', gameSession.pin);
            
            // CRITICAL: Stop the lobby listener to avoid conflicts
            stopRealTimeListener();
            
            // Hide the lobby screen
            document.getElementById('lobbyScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'none';
            
            // Wait for game state to be available in Firebase
            let attempts = 0;
            const maxAttempts = 20; // 20 seconds max wait
            
            while (attempts < maxAttempts) {
                try {
                    const gameState = await loadGameStateFromCloud(gameSession.pin);
                    
                    if (gameState && gameState.players && gameState.players.length > 0) {
                        console.log('‚úÖ Got game state from Firebase');
                        console.log('Players in game state:', gameState.players.map(p => p.name));
                        
                        // Reconstruct Player objects properly
                        game.players = gameState.players.map(p => {
                            const player = new Player(p.name);
                            // Reconstruct Card objects in player's hand
                            player.hand = (p.hand || []).map(cardData => new Card(cardData.value, cardData.type));
                            player.isDisqualified = p.isDisqualified || false;
                            player.hasFinished = p.hasFinished || false;
                            player.isPaused = p.isPaused || false;
                            player.pausedUntil = p.pausedUntil || 0;
                            return player;
                        });
                        
                        // Reconstruct Card objects in deck and discard pile
                        game.deck = (gameState.deck || []).map(cardData => new Card(cardData.value, cardData.type));
                        game.discardPile = (gameState.discardPile || []).map(cardData => new Card(cardData.value, cardData.type));
                        game.currentPlayerIndex = gameState.currentPlayerIndex || 0;
                        game.roundNumber = gameState.roundNumber || 1;
                        game.highCardPlayedThisRound = gameState.highCardPlayedThisRound || false;
                        game.gameOver = gameState.gameOver || false;
                        game.winner = gameState.winner || null;
                        game.direction = gameState.direction || 1;
                        
                        // Set current player index for this client
                        const myPlayerIndex = game.players.findIndex(p => p.name === gameSession.playerName);
                        if (myPlayerIndex !== -1) {
                            gameSession.currentPlayerIndex = myPlayerIndex;
                        }
                        
                        console.log(`‚úÖ Game initialized! Your player index: ${myPlayerIndex}`);
                        console.log('Game players:', game.players.map(p => `${p.name}: ${p.hand.length} cards, active=${p.isActive()}, disq=${p.isDisqualified}, finished=${p.hasFinished}`));
                        console.log('Game state - gameOver:', game.gameOver, 'winner:', game.winner);
                        
                        const activePlayers = game.players.filter(p => p.isActive());
                        console.log('Active players count:', activePlayers.length, 'Total players:', game.players.length);
                        
                        // Hide setup modal and show game
                        document.getElementById('setupModal').style.display = 'none';
                        const gameContainer = document.querySelector('.game-container');
                        if (gameContainer) {
                            gameContainer.style.display = 'block';
                        }
                        showMessage('üéÆ Game started! Ready to play!', 'success');
                        updateDisplay();
                        // Mark initialization as complete so checkGameOver can run normally now
                        gameInitializationComplete = true;
                        
                        // Start listening for real-time game state updates
                        startGameStateListener(gameSession.pin);
                        return true;
                    }
                    
                } catch (error) {
                    console.error('Error loading game state:', error);
                }
                
                attempts++;
                console.log(`Waiting for game state... attempt ${attempts}/${maxAttempts}`);
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            console.error('‚ùå Failed to load game state after', maxAttempts, 'attempts');
            showError('Failed to load game. Please try again.');
            return false;
        }

        async function startGameFromLobby() {
            audioManager?.playSound('buttonClick');
            const requiredPlayers = gameSession.maxPlayers || 4;
            const currentPlayerCount = Object.keys(gameSession.lobbyPlayers).length;
            
            if (!gameSession.isHost || currentPlayerCount < requiredPlayers) {
                alert(`Need exactly ${requiredPlayers} players to start the game! Currently have ${currentPlayerCount}.`);
                return;
            }

            // Update cloud to notify all players game is starting
            try {
                const sessionData = await loadGameFromCloud(gameSession.pin);
                if (sessionData) {
                    sessionData.gameStarted = true;
                    // Use update instead of save to avoid "already exists" error
                    const gameRef = firebase.database().ref(`games/${gameSession.pin}`);
                    await gameRef.update({ gameStarted: true });
                }
            } catch (error) {
                console.error('Error updating game start status:', error);
            }

            // Stop real-time updates and start the actual game
            stopRealTimeListener();
            startActualGame();
        }

        async function startActualGame() {
            // Only the host initializes the game state
            if (gameSession.isHost) {
                console.log('üéÆ Host initializing game state...');
                
                // Convert lobbyPlayers object to array of player names
                const lobbyPlayersArray = Object.values(gameSession.lobbyPlayers);
                const playerNames = lobbyPlayersArray.map(p => p.name);
                
                game = {
                    players: playerNames.map(name => new Player(name)),
                    deck: createDeck(),
                    discardPile: [],
                    currentPlayerIndex: 0,
                    roundNumber: 1,
                    highCardPlayedThisRound: false,
                    gameOver: false,
                    winner: null,
                    direction: 1
                };

                dealCards();
                
                // Save initial game state to Firebase - include ALL player properties
                await saveGameStateToCloud(gameSession.pin, {
                    players: game.players.map(p => ({
                        name: p.name,
                        hand: p.hand,
                        active: p.active !== undefined ? p.active : true,
                        isDisqualified: p.isDisqualified || false,
                        hasFinished: p.hasFinished || false,
                        isPaused: p.isPaused || false,
                        pausedUntil: p.pausedUntil || 0
                    })),
                    deck: game.deck,
                    discardPile: game.discardPile,
                    currentPlayerIndex: game.currentPlayerIndex,
                    roundNumber: game.roundNumber,
                    highCardPlayedThisRound: game.highCardPlayedThisRound,
                    gameOver: game.gameOver,
                    winner: game.winner,
                    direction: game.direction,
                    lastMoveBy: 'HOST_INIT',
                    timestamp: Date.now()
                });
                
                console.log('‚úÖ Initial game state saved to Firebase');
            } else {
                console.log('üéÆ Non-host waiting for game state...');
                // Non-host players wait and load game state from Firebase
                let attempts = 0;
                while (attempts < 10) {
                    const gameState = await loadGameStateFromCloud(gameSession.pin);
                    if (gameState && gameState.players) {
                        // Reconstruct Player objects properly
                        game = {
                            players: gameState.players.map(p => {
                                const player = new Player(p.name);
                                // Reconstruct Card objects in player's hand
                                player.hand = (p.hand || []).map(cardData => new Card(cardData.value, cardData.type));
                                player.active = p.active !== undefined ? p.active : true;
                                return player;
                            }),
                            // Reconstruct Card objects in deck and discard pile
                            deck: (gameState.deck || []).map(cardData => new Card(cardData.value, cardData.type)),
                            discardPile: (gameState.discardPile || []).map(cardData => new Card(cardData.value, cardData.type)),
                            currentPlayerIndex: gameState.currentPlayerIndex || 0,
                            roundNumber: gameState.roundNumber || 1,
                            highCardPlayedThisRound: gameState.highCardPlayedThisRound || false,
                            gameOver: gameState.gameOver || false,
                            winner: gameState.winner || null,
                            direction: gameState.direction || 1
                        };
                        console.log('‚úÖ Game state loaded from Firebase');
                        break;
                    }
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }

            // Set current player ID for card visibility
            gameSession.gameStarted = true;
            const currentPlayerIndex = game.players.findIndex(p => p.name === gameSession.playerName);
            if (currentPlayerIndex !== -1) {
                gameSession.currentPlayerIndex = currentPlayerIndex;
            }

            console.log('Game started from lobby:');
            console.log('Players:', game.players.map(p => `${p.name}: ${p.hand.length} cards`));
            console.log('Current player for this client:', gameSession.playerName);
            
            document.getElementById('setupModal').style.display = 'none';
            const gameContainer = document.querySelector('.game-container');
            if (gameContainer) {
                gameContainer.style.display = 'block';
            }
            showMessage('Game started! Each player has 7 cards.', 'success');
            updateDisplay();
            // Mark initialization as complete so checkGameOver can run normally now
            gameInitializationComplete = true;
            
            // Start listening for game state changes
            startGameStateListener(gameSession.pin);
        }

        // Player count selection variables
        let selectedPlayerCount = 4; // Default to 4 players

        function selectPlayerCount(count) {
            audioManager?.playSound('buttonClick');
            selectedPlayerCount = count;
            
            // Update UI to show selected state - only for local game buttons
            document.querySelectorAll('.player-count-btn:not(.online-mode)').forEach(btn => {
                btn.classList.remove('selected');
            });
            const targetBtn = document.querySelector(`.player-count-btn:not(.online-mode)[data-count="${count}"]`);
            if (targetBtn) {
                targetBtn.classList.add('selected');
            }
            
            console.log(`Selected player count: ${count}`);
        }

        function selectOnlinePlayerCount(count) {
            audioManager?.playSound('buttonClick');
            
            // Update UI to show selected state - only for online game buttons
            document.querySelectorAll('.player-count-btn.online-mode').forEach(btn => {
                btn.classList.remove('selected');
            });
            const targetBtn = document.querySelector(`.player-count-btn.online-mode[data-count="${count}"]`);
            if (targetBtn) {
                targetBtn.classList.add('selected');
            }
            
            console.log(`Selected online player count: ${count}`);
            joinOnlineQueue(count);
        }

        // Enhanced click event handling for player count buttons
        function initPlayerCountButtons() {
            // Handle local game player count section
            const playerCountSection = document.getElementById('playerCountSection');
            
            // Remove existing delegated listeners
            const existingHandler = playerCountSection._clickHandler;
            if (existingHandler) {
                playerCountSection.removeEventListener('click', existingHandler);
                playerCountSection.removeEventListener('touchend', existingHandler);
            }
            
            // Create new handler

            const handlePlayerCountClick = (e) => {
                const btn = e.target.closest('.player-count-btn');
                if (btn) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const count = parseInt(btn.getAttribute('data-count'));
                    console.log('üéØ Player count button clicked:', count);
                    audioManager?.playSound('buttonClick');
                    selectPlayerCount(count);
                }
            };
            
            // Store handler reference and add listeners
            playerCountSection._clickHandler = handlePlayerCountClick;
            playerCountSection.addEventListener('click', handlePlayerCountClick);
            playerCountSection.addEventListener('touchend', handlePlayerCountClick);
            
            // Also ensure buttons are properly initialized
            document.querySelectorAll('.player-count-btn').forEach(btn => {
                const count = parseInt(btn.getAttribute('data-count'));
                
                // Backup direct listener for compatibility
                btn.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('üéØ Direct click on player count:', count);
                    audioManager?.playSound('buttonClick');
                    selectPlayerCount(count);
                };
                
                // Ensure proper attributes
                btn.style.pointerEvents = 'auto';
                btn.style.cursor = 'pointer';
                
                // Add visual feedback
                btn.addEventListener('mousedown', (e) => {
                    btn.style.transform = 'scale(0.95)';
                });
                
                btn.addEventListener('mouseup', (e) => {
                    btn.style.transform = '';
                });
                
                btn.addEventListener('mouseleave', (e) => {
                    btn.style.transform = '';
                });
            });
            
            console.log('üéÆ Player count buttons initialized with enhanced event handling');

            // Initialize online game player count buttons
            const onlinePlayerCountSection = document.getElementById('onlinePlayerCountSection');
            if (onlinePlayerCountSection) {
                // Remove existing delegated listeners
                const existingOnlineHandler = onlinePlayerCountSection._clickHandler;
                if (existingOnlineHandler) {
                    onlinePlayerCountSection.removeEventListener('click', existingOnlineHandler);
                    onlinePlayerCountSection.removeEventListener('touchend', existingOnlineHandler);
                }
                
                // Create handler for online buttons
                const handleOnlinePlayerCountClick = (e) => {
                    const btn = e.target.closest('.player-count-btn.online-mode');
                    if (btn) {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const count = parseInt(btn.getAttribute('data-count'));
                        console.log('üéØ Online player count button clicked:', count);
                        audioManager?.playSound('buttonClick');
                        selectOnlinePlayerCount(count);
                    }
                };
                
                // Store handler reference and add listeners
                onlinePlayerCountSection._clickHandler = handleOnlinePlayerCountClick;
                onlinePlayerCountSection.addEventListener('click', handleOnlinePlayerCountClick);
                onlinePlayerCountSection.addEventListener('touchend', handleOnlinePlayerCountClick);
                
                // Direct listeners on each button for backup
                document.querySelectorAll('.player-count-btn.online-mode').forEach(btn => {
                    const count = parseInt(btn.getAttribute('data-count'));
                    
                    btn.onclick = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('üéØ Direct click on online player count:', count);
                        audioManager?.playSound('buttonClick');
                        selectOnlinePlayerCount(count);
                    };
                    
                    // Ensure proper attributes
                    btn.style.pointerEvents = 'auto';
                    btn.style.cursor = 'pointer';
                    
                    // Add visual feedback
                    btn.addEventListener('mousedown', (e) => {
                        btn.style.transform = 'scale(0.95)';
                    });
                    
                    btn.addEventListener('mouseup', (e) => {
                        btn.style.transform = '';
                    });
                    
                    btn.addEventListener('mouseleave', (e) => {
                        btn.style.transform = '';
                    });
                });
                
                console.log('üéÆ Online player count buttons initialized');
            }
        }

        // Debug function to test button interactions
        function testButtonInteractions() {
            console.log('üß™ Testing button interactions...');
            
            const buttons = document.querySelectorAll('.player-count-btn');
            console.log(`Found ${buttons.length} player count buttons`);
            
            buttons.forEach((btn, index) => {
                const count = btn.getAttribute('data-count');
                console.log(`Button ${index + 1}: data-count=${count}, visible=${btn.offsetWidth > 0}`);
                
                // Test if button is clickable
                const rect = btn.getBoundingClientRect();
                console.log(`Button ${index + 1} position:`, {
                    top: rect.top,
                    left: rect.left,
                    width: rect.width,
                    height: rect.height,
                    visible: rect.width > 0 && rect.height > 0
                });
            });
        }

        // Reset game creation back to initial state
        function resetGameCreation() {
            const playerCountSection = document.getElementById('playerCountSection');
            const createBtn = document.getElementById('createGameBtn');
            const gameCreationControls = document.getElementById('gameCreationControls');
            
            // Hide player count section
            playerCountSection.style.display = 'none';
            
            // Reset button text
            createBtn.textContent = 'üéÆ Create Game';
            
            // Hide back button
            gameCreationControls.style.display = 'none';
            
            // Clear selection
            document.querySelectorAll('.player-count-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
        }

        // Special Card Animation Functions
        function playSpecialCardAnimation(cardType) {
            // Remove any existing animations first
            const existingAnimation = document.querySelector('.special-card-animation');
            if (existingAnimation) {
                existingAnimation.remove();
            }

            const animationContainer = document.createElement('div');
            animationContainer.className = 'special-card-animation';

            switch (cardType) {
                case 'peak':
                    playPeakAnimation(animationContainer);
                    break;
                case 'reverse':
                    playReverseAnimation(animationContainer);
                    break;
                case 'star':
                    playStarAnimation(animationContainer);
                    break;
                case 'goblin':
                    playGoblinAnimation(animationContainer);
                    break;
                case 'pause':
                    playPauseAnimation(animationContainer);
                    break;
            }

            document.body.appendChild(animationContainer);

            // Remove animation after it completes
            setTimeout(() => {
                if (animationContainer.parentNode) {
                    animationContainer.remove();
                }
            }, 3000);
        }

        function playPeakAnimation(container) {
            container.classList.add('peak-animation');
            
            const peakText = document.createElement('div');
            peakText.className = 'peak-text';
            peakText.textContent = 'PEAAAKKK';
            container.appendChild(peakText);

            // Add screen shake effect
            document.body.style.animation = 'none';
            setTimeout(() => {
                document.body.style.animation = 'shake 0.5s ease-in-out';
            }, 10);
        }

        function playReverseAnimation(container) {
            container.classList.add('reverse-animation');
            
            const emoji = document.createElement('div');
            emoji.className = 'reverse-emoji';
            emoji.textContent = 'üîÑ';
            container.appendChild(emoji);
        }

        function playStarAnimation(container) {
            container.classList.add('star-animation');
            
            const emoji = document.createElement('div');
            emoji.className = 'star-emoji';
            emoji.textContent = '‚ú®';
            container.appendChild(emoji);

            // Create sparkle particles
            for (let i = 0; i < 8; i++) {
                setTimeout(() => {
                    const sparkle = document.createElement('div');
                    sparkle.className = 'sparkle-particle';
                    sparkle.textContent = '‚≠ê';
                    
                    const angle = (i / 8) * 360;
                    const distance = 200;
                    const x = Math.cos(angle * Math.PI / 180) * distance;
                    const y = Math.sin(angle * Math.PI / 180) * distance;
                    
                    sparkle.style.left = `calc(50% + ${x}px)`;
                    sparkle.style.top = `calc(50% + ${y}px)`;
                    sparkle.style.animationDelay = `${i * 0.1}s`;
                    
                    container.appendChild(sparkle);
                }, i * 100);
            }
        }

        function playGoblinAnimation(container) {
            container.classList.add('goblin-animation');
            
            const emoji = document.createElement('div');
            emoji.className = 'goblin-emoji';
            emoji.textContent = 'üëπ';
            container.appendChild(emoji);
        }

        function playPauseAnimation(container) {
            container.classList.add('pause-animation');
            
            const emoji = document.createElement('div');
            emoji.className = 'pause-emoji';
            emoji.textContent = '‚è∏Ô∏è';
            container.appendChild(emoji);

            // Add a clock overlay effect
            setTimeout(() => {
                const clock = document.createElement('div');
                clock.style.position = 'absolute';
                clock.style.fontSize = '4em';
                clock.style.opacity = '0.8';
                clock.textContent = 'üïê';
                clock.style.animation = 'spin 1s linear infinite';
                container.appendChild(clock);
            }, 500);
        }

        // Add vibration for mobile devices when special cards are played
        function triggerVibration(pattern = [100, 50, 100]) {
            if (navigator.vibrate) {
                navigator.vibrate(pattern);
            }
        }

        // Enhanced special card animation with haptic feedback
        function playSpecialCardAnimationEnhanced(cardType) {
            playSpecialCardAnimation(cardType);
            
            // Different vibration patterns for different cards
            switch (cardType) {
                case 'peak':
                    triggerVibration([200, 100, 200, 100, 200]); // Strong peak shake
                    break;
                case 'reverse':
                    triggerVibration([50, 50, 50, 50]); // Quick alternating
                    break;
                case 'star':
                    triggerVibration([100, 50, 100, 50, 100, 50]); // Sparkle pattern
                    break;
                case 'goblin':
                    triggerVibration([150, 75, 150, 75]); // Chaotic pattern
                    break;
                case 'pause':
                    triggerVibration([300]); // Long pause vibration
                    break;
            }
        }

        // Broadcast animation to all players via Firebase
        async function broadcastSpecialCardAnimation(cardType, playerName) {
            if (gameSession.pin) {
                try {
                    const animationData = {
                        type: cardType,
                        playerName: playerName,
                        timestamp: Date.now(),
                        id: Math.random().toString(36).substr(2, 9),
                        effectApplied: false,
                        soundEffect: getSoundEffectForCard(cardType)
                    };
                    
                    // Simple broadcast - just add animation without complex nested updates
                    const gameRef = firebase.database().ref(`games/${gameSession.pin}/animations`);
                    
                    try {
                        // Simply push new animation
                        await gameRef.push(animationData);
                        console.log(`üì° Broadcasted ${cardType} animation from ${playerName}`);
                    } catch (error) {
                        // If animations node doesn't exist, create it
                        if (error.code === 'PERMISSION_DENIED' || error.message?.includes('Cannot write')) {
                            console.log('‚ö†Ô∏è Animation write failed, skipping broadcast');
                        } else {
                            console.error('‚ùå Error broadcasting animation:', error);
                        }
                    }
                } catch (error) {
                    console.log('‚ùå Failed to broadcast animation:', error);
                }
            }
            
            // Play locally for the player who played the card
            playSpecialCardAnimationEnhanced(cardType);
            playSpecialCardSound(cardType);
        }

        // Helper function to get the appropriate sound effect for each card type
        function getSoundEffectForCard(cardType) {
            switch (cardType) {
                case 'peak':
                    return 'peakCard';
                case 'star':
                    return 'starSound';
                case 'goblin':
                    return 'goblinSound';
                case 'pause':
                    return 'buttonClick';
                case 'reverse':
                    return 'buttonClick';
                default:
                    return 'cardPlace';
            }
        }

        // Play the special card sound effect
        function playSpecialCardSound(cardType) {
            const soundEffect = getSoundEffectForCard(cardType);
            audioManager?.playSound(soundEffect, cardType === 'peak' ? 0.8 : 0.6);
        }

        // Listen for animation broadcasts and special effects from other players
        let lastProcessedAnimationId = null;
        let processedEffects = new Set();
        let currentlyPlayingAnimation = false;  // Prevent simultaneous animations
        
        function processAnimationBroadcasts(gameData) {
            if (!gameData) return;
            
            // Process animations
            if (gameData.animations && Array.isArray(gameData.animations)) {
                const animationsToRemove = [];
                
                gameData.animations.forEach(animation => {
                    // Check if we haven't processed this animation yet
                    if (!processedEffects.has(animation.id)) {
                        // Don't show your own animations twice
                        if (animation.playerName !== gameSession.playerName && !currentlyPlayingAnimation) {
                            console.log(`üé¨ Playing ${animation.type} animation from ${animation.playerName}`);
                            
                            // Set flag to prevent duplicate plays
                            currentlyPlayingAnimation = true;
                            
                            // Play both animation and sound
                            playSpecialCardAnimationEnhanced(animation.type);
                            playSpecialCardSound(animation.type);
                            
                            // Show message about special card
                            const messages = {
                                'peak': `‚ö° ${animation.playerName} played a Peak card!`,
                                'star': `‚ú® ${animation.playerName} played a Star card!`,
                                'goblin': `üëπ ${animation.playerName} played a Goblin card!`,
                                'reverse': `üîÑ ${animation.playerName} played a Reverse card!`,
                                'pause': `‚è∏Ô∏è ${animation.playerName} played the Legendary Pause card!`
                            };
                            showMessage(messages[animation.type] || `${animation.playerName} played a special card!`, 'special');
                            
                            // Reset flag after animation completes
                            setTimeout(() => {
                                currentlyPlayingAnimation = false;
                            }, 1000);
                        }
                        // Mark this animation as processed
                        processedEffects.add(animation.id);
                        // Mark for removal from Firebase
                        animationsToRemove.push(animation.id);
                    }
                });
                
                // Clean up processed animations from Firebase
                if (animationsToRemove.length > 0 && gameSession.isHost) {
                    const gameRef = firebase.database().ref(`games/${gameSession.pin}`);
                    const remainingAnimations = gameData.animations.filter(a => !animationsToRemove.includes(a.id));
                    gameRef.update({ animations: remainingAnimations }).catch(err => {
                        console.log('Could not clean up animations:', err);
                    });
                }
            }
            
            // Process special effects
            if (gameData.effectStatus) {
                Object.entries(gameData.effectStatus).forEach(async ([effectId, effect]) => {
                    if (!processedEffects.has(effectId) && effect.playerName !== gameSession.playerName) {
                        // Check if the effect is recent (within last 10 seconds)
                        const isRecent = (Date.now() - effect.timestamp) < 10000;
                        
                        if (isRecent && !effect.effectApplied) {
                            console.log(`üéØ Applying ${effect.type} effect from ${effect.playerName}`);
                            
                            // Apply the effect locally
                            switch (effect.type) {
                                case 'peak':
                                    await handlePeakCardEffect();
                                    break;
                                case 'reverse':
                                    handleReverseCardEffect();
                                    break;
                                case 'star':
                                    handleStarCardEffect();
                                    break;
                                case 'goblin':
                                    handleGoblinCardEffect();
                                    break;
                                case 'pause':
                                    handlePauseCardEffect();
                                    break;
                            }
                            
                            // Mark effect as processed locally
                            processedEffects.add(effectId);
                            
                            // Update effect status in Firebase
                            if (gameSession.pin) {
                                const currentData = await loadGameFromCloud(gameSession.pin);
                                if (currentData && currentData.effectStatus && currentData.effectStatus[effectId]) {
                                    currentData.effectStatus[effectId].effectApplied = true;
                                    await saveGameToCloud(gameSession.pin, currentData);
                                }
                            }
                        }
                    }
                });
                
                // Clean up old effects from memory
                const tenSecondsAgo = Date.now() - 10000;
                Object.entries(gameData.effectStatus).forEach(([effectId, effect]) => {
                    if (effect.timestamp < tenSecondsAgo) {
                        processedEffects.delete(effectId);
                    }
                });
            }
        }

        // Handle game action button (New Game for host, Leave Game for non-host)
        // Individual effect handlers for remote synchronization
        async function handlePeakCardEffect() {
            // Only add cards if we're the next player
            if (getNextActivePlayer().name === gameSession.playerName) {
                const cards = [];
                // Give 5 cards or as many as possible from the deck
                for (let i = 0; i < 5 && game.deck.length > 0; i++) {
                    cards.push(game.deck.pop());
                }
                const nextPlayer = getNextActivePlayer();
                nextPlayer.addCards(cards);
                
                showMessage(`You picked up ${cards.length} cards due to Peak card!`, 'warning');
                
                if (nextPlayer.isDisqualified) {
                    showMessage(`You are disqualified for having over 20 cards!`, 'error');
                }
            }
        }
        
        function handleReverseCardEffect() {
            game.direction *= -1;  // Flip the direction
            const directionText = game.direction === 1 ? 'clockwise' : 'counter-clockwise';
            showMessage(`üîÑ Direction reversed! Now playing ${directionText}`, 'info');
        }
        
        function handleStarCardEffect() {
            // Only remove Peak cards if we're not the one who played the Star card
            if (game.players[game.currentPlayerIndex].name !== gameSession.playerName) {
                console.log('‚ú® Checking for Peak cards to remove');
                const ourPlayer = game.players.find(p => p.name === gameSession.playerName);
                if (ourPlayer && ourPlayer.isActive()) {
                    // Find and remove all Peak cards from our hand
                    const peakCards = [];
                    for (let i = ourPlayer.hand.length - 1; i >= 0; i--) {
                        if (ourPlayer.hand[i].isPeakCard()) {
                            peakCards.push(ourPlayer.hand.splice(i, 1)[0]);
                        }
                    }
                    
                    if (peakCards.length > 0) {
                        showMessage(`‚ú® ${peakCards.length} Peak card(s) were removed from your hand!`, 'info');
                        console.log(`Lost ${peakCards.length} Peak cards`);
                        
                        // Put the Peak cards back into the deck
                        game.deck.push(...peakCards);
                        game.deck = shuffleDeck(game.deck);
                    }
                }
            }
        }
        
        function handleGoblinCardEffect() {
            // Only add bad cards if we're not the one who played the Goblin card
            if (game.players[game.currentPlayerIndex].name !== gameSession.playerName) {
                console.log('üëπ Receiving bad card from Goblin');
                const ourPlayer = game.players.find(p => p.name === gameSession.playerName);
                if (ourPlayer && ourPlayer.isActive()) {
                    const badCards = [1, 2, 3, 4];
                    const badCardValue = badCards[Math.floor(Math.random() * badCards.length)];
                    const badCard = new Card(badCardValue, CardType.REGULAR);
                    ourPlayer.addCard(badCard);
                    
                    showMessage(`üëπ You received a ${badCardValue} card from the Goblin!`, 'warning');
                    
                    if (ourPlayer.isDisqualified) {
                        showMessage(`You are disqualified for having over 20 cards!`, 'error');
                    }
                }
            }
        }
        
        function handlePauseCardEffect() {
            const nextPlayer = getNextActivePlayer();
            if (nextPlayer && nextPlayer.name === gameSession.playerName) {
                // Set pause timer for 2 minutes (120 seconds)
                nextPlayer.pausedUntil = Date.now() + (2 * 60 * 1000);
                nextPlayer.isPaused = true;
                
                showMessage(`‚è∏Ô∏è You are paused for 2 minutes!`, 'warning');
                
                // Start a timer to unpause
                setTimeout(() => {
                    if (nextPlayer.isPaused) {
                        nextPlayer.isPaused = false;
                        nextPlayer.pausedUntil = 0;
                        showMessage(`‚ñ∂Ô∏è You are no longer paused!`, 'info');
                        updateDisplay();
                    }
                }, 2 * 60 * 1000);
            }
        }

        function handleGameAction() {
            if (gameSession.isHost) {
                // Host can start new game or end current game
                if (game.gameOver) {
                    startNewGame();
                } else {
                    endCurrentGame();
                }
            } else {
                // Non-host can leave game
                leaveGame();
            }
        }

        // Start a new game (host only)
        async function startNewGame() {
            if (!gameSession.isHost) {
                showMessage("Only the host can start a new game!", 'error');
                return;
            }

            if (confirm("Start a new game? This will reset the current game.")) {
                // Reset game state
                game = {
                    players: gameSession.lobbyPlayers.map(p => new Player(p.name)),
                    deck: createDeck(),
                    discardPile: [],
                    currentPlayerIndex: 0,
                    roundNumber: 1,
                    highCardPlayedThisRound: false,
                    gameOver: false,
                    winner: null,
                    direction: 1
                };

                dealCards();

                // Save new game state to Firebase
                await saveGameStateToCloud(gameSession.pin, {
                    players: game.players.map(p => ({
                        name: p.name,
                        hand: p.hand,
                        active: p.active,
                        isDisqualified: p.isDisqualified,
                        hasFinished: p.hasFinished,
                        isPaused: p.isPaused,
                        pausedUntil: p.pausedUntil
                    })),
                    deck: game.deck,
                    discardPile: game.discardPile,
                    currentPlayerIndex: game.currentPlayerIndex,
                    roundNumber: game.roundNumber,
                    highCardPlayedThisRound: game.highCardPlayedThisRound,
                    gameOver: game.gameOver,
                    winner: game.winner,
                    direction: game.direction,
                    timestamp: Date.now(),
                    lastMoveBy: gameSession.playerName
                });

                showMessage('üéÆ New game started!', 'success');
                updateDisplay();
            }
        }

        // End current game (host only)
        async function endCurrentGame() {
            if (!gameSession.isHost) {
                showMessage("Only the host can end the game!", 'error');
                return;
            }

            if (confirm("End the current game? All players will return to the lobby.")) {
                // Mark game as ended
                game.gameOver = true;
                
                // Save final game state
                await saveGameStateToCloud(gameSession.pin, {
                    players: game.players.map(p => ({
                        name: p.name,
                        hand: p.hand,
                        active: p.active,
                        isDisqualified: p.isDisqualified,
                        hasFinished: p.hasFinished,
                        isPaused: p.isPaused,
                        pausedUntil: p.pausedUntil
                    })),
                    deck: game.deck,
                    discardPile: game.discardPile,
                    currentPlayerIndex: game.currentPlayerIndex,
                    roundNumber: game.roundNumber,
                    highCardPlayedThisRound: game.highCardPlayedThisRound,
                    gameOver: true,
                    winner: null,
                    direction: game.direction,
                    timestamp: Date.now(),
                    lastMoveBy: gameSession.playerName,
                    gameEnded: true
                });

                showMessage('üèÅ Game ended by host', 'info');
                
                // Return players to start screen
                setTimeout(() => {
                    window.location.reload();
                }, 2000);
            }
        }

        // Leave game (non-host only)
        async function leaveGame() {
            if (gameSession.isHost) {
                showMessage("Hosts should use 'End Game' instead of leaving!", 'error');
                return;
            }

            if (confirm("Leave the game? You will return to the start screen.")) {
                // Remove player from lobby
                const sessionData = await loadGameFromCloud(gameSession.pin);
                if (sessionData) {
                    sessionData.lobbyPlayers = sessionData.lobbyPlayers.filter(p => p.id !== gameSession.playerId);
                    await saveGameToCloud(gameSession.pin, sessionData);
                }

                // Clear session data
                gameSession = {
                    pin: null,
                    isHost: false,
                    playerName: '',
                    playerId: null,
                    lobbyPlayers: [],
                    gameStarted: false
                };

                // Stop listeners
                stopRealTimeListener();
                stopGameStateListener();

                // Return to start screen
                document.getElementById('setupModal').style.display = 'block';
                showMessage('üëã You left the game', 'info');
            }
        }

        // Legacy function for compatibility
        function startGame() {
            startGameFromLobby();
        }

        function showSetup() {
            document.getElementById('setupModal').style.display = 'block';
            document.getElementById('gameOverModal').style.display = 'none';
        }

        // Handle play again - return to lobby
        async function handlePlayAgain() {
            console.log('üîÑ Player wants to play again');
            
            // Stop listening to game updates
            stopRealTimeListener();
            
            // Redirect to setup screen for them to rejoin
            document.getElementById('gameOverModal').style.display = 'none';
            document.getElementById('setupModal').style.display = 'block';
            
            // Reset game state
            gameSession.gameStarted = false;
            game = {
                players: [],
                deck: [],
                discardPile: [],
                currentPlayerIndex: 0,
                roundNumber: 1,
                highCardPlayedThisRound: false,
                gameOver: false,
                winner: null,
                direction: 1
            };
            
            showMessage('Ready to play again! The lobby is waiting for you.', 'success');
        }

        // Handle leave game - return to start screen
        async function handleLeaveGame() {
            console.log('‚ùå Player leaving game');
            
            // Stop listening to game updates
            stopRealTimeListener();
            
            // Reset everything
            gameSession = {
                pin: null,
                isHost: false,
                playerName: '',
                playerId: null,
                lobbyPlayers: {},
                gameStarted: false
            };
            
            game = {
                players: [],
                deck: [],
                discardPile: [],
                currentPlayerIndex: 0,
                roundNumber: 1,
                highCardPlayedThisRound: false,
                gameOver: false,
                winner: null,
                direction: 1
            };
            
            // Hide all modals and go back to start
            document.getElementById('gameOverModal').style.display = 'none';
            document.getElementById('setupModal').style.display = 'block';
            document.getElementById('gameContainer').style.display = 'none';
            
            // Reset the setup form
            document.getElementById('playerName').value = '';
            document.getElementById('gamePin').value = '';
            
            showMessage('You have left the game. Welcome back to Peak!', 'info');
        }

        // Handle end game (host only) - ends for everyone
        async function handleEndGame() {
            console.log('‚èπÔ∏è Host ending game for everyone');
            
            try {
                // Update Firebase to mark game as ended
                const gameRef = firebase.database().ref(`games/${gameSession.pin}`);
                await gameRef.update({
                    gameEnded: true,
                    endedAt: firebase.database.ServerValue.TIMESTAMP
                });
                
                // Notify all players
                showMessage('Host has ended the game. Everyone will return to start screen.', 'info');
                
                // Give players time to see the message
                setTimeout(() => {
                    // Stop listening
                    stopRealTimeListener();
                    
                    // Reset everything
                    gameSession = {
                        pin: null,
                        isHost: false,
                        playerName: '',
                        playerId: null,
                        lobbyPlayers: {},
                        gameStarted: false
                    };
                    
                    game = {
                        players: [],
                        deck: [],
                        discardPile: [],
                        currentPlayerIndex: 0,
                        roundNumber: 1,
                        highCardPlayedThisRound: false,
                        gameOver: false,
                        winner: null,
                        direction: 1
                    };
                    
                    // Hide all modals and go back to start
                    document.getElementById('gameOverModal').style.display = 'none';
                    document.getElementById('setupModal').style.display = 'block';
                    document.getElementById('gameContainer').style.display = 'none';
                    
                    // Reset the setup form
                    document.getElementById('playerName').value = '';
                    document.getElementById('gamePin').value = '';
                }, 1000);
            } catch (error) {
                console.error('Error ending game:', error);
                showMessage('Error ending game', 'error');
            }
        }

        function showGameState() {
            const activePlayers = game.players.filter(p => p.isActive()).length;
            const message = `Round: ${game.roundNumber}\nActive Players: ${activePlayers}\nCards in Deck: ${game.deck.length}\nHigh Card Played: ${game.highCardPlayedThisRound ? 'Yes' : 'No'}`;
            alert(message);
        }

        function toggleRules() {
            const panel = document.getElementById('rulesPanel');
            panel.style.display = panel.style.display === 'block' ? 'none' : 'block';
        }

        // Copy share link to clipboard
        function copyShareLink() {
            const shareUrl = document.getElementById('shareUrl').textContent;
            navigator.clipboard.writeText(shareUrl).then(() => {
                const button = event.target;
                const originalText = button.textContent;
                button.textContent = '‚úÖ Copied!';
                button.style.background = '#4CAF50';
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = '#2196F3';
                }, 2000);
            }).catch(() => {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = shareUrl;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                alert('Link copied to clipboard!');
            });
        }

        // Initialize game
        window.onload = function() {
            showSetup();
            checkUrlForPin(); // Check if PIN is in URL
            
            // Add PIN input validation
            const pinInput = document.getElementById('gamePin');
            const joinBtn = document.getElementById('joinBtn');
            const playerNameInput = document.getElementById('playerName');
            
            // Player count selection will show when Create Game is clicked
            
            pinInput.addEventListener('input', function() {
                const pin = this.value.trim();
                joinBtn.disabled = !(pin.length === 4 && /^\d{4}$/.test(pin));
            });
            
            // Allow only numbers in PIN input
            pinInput.addEventListener('keypress', function(e) {
                if (!/\d/.test(e.key) && !['Backspace', 'Delete', 'Tab', 'Enter'].includes(e.key)) {
                    e.preventDefault();
                }
            });
        };

        // Close modals when clicking outside
        window.onclick = function(event) {
            const setupModal = document.getElementById('setupModal');
            const gameOverModal = document.getElementById('gameOverModal');
            const settingsModal = document.getElementById('settingsModal');
            const rulesPanel = document.getElementById('rulesPanel');
            
            if (event.target === setupModal) {
                setupModal.style.display = 'none';
            }
            if (event.target === gameOverModal) {
                gameOverModal.style.display = 'none';
            }
            if (event.target === settingsModal) {
                settingsModal.style.display = 'none';
            }
            if (!event.target.closest('.rules-toggle') && !event.target.closest('.rules-panel')) {
                rulesPanel.style.display = 'none';
            }
        };
        
        // Audio System with Multi-Format Support
        class AudioManager {
            constructor() {
                this.bgMusic = document.getElementById('bgMusic');
                this.sounds = {
                    cardFlip: document.getElementById('cardFlip'),
                    cardPlace: document.getElementById('cardPlace'),
                    peakCard: document.getElementById('peakCard'),
                    winSound: document.getElementById('winSound'),
                    loseSound: document.getElementById('loseSound'),
                    buttonClick: document.getElementById('buttonClick'),
                    goblinSound: document.getElementById('goblinSound'),
                    starSound: document.getElementById('starSound')
                    // turnNotification removed - file not available
                };
                
                this.musicEnabled = true;
                this.sfxEnabled = true;
                this.volume = 0.5;
                this.musicStarted = false;
                
                // Audio format support detection
                this.supportedFormats = this.detectAudioSupport();
                
                console.log('üéµ Audio Manager initialized with multi-format support');
                console.log('üé∂ Supported formats:', this.supportedFormats);
                
                // Set initial volumes and test audio elements
                this.updateVolumes();
                this.testAudioElements();
                
                // Setup user interaction listeners
                this.setupAutoPlay();
            }
            
            detectAudioSupport() {
                const audio = document.createElement('audio');
                return {
                    mp3: !!audio.canPlayType('audio/mpeg').replace(/no/, ''),
                    wav: !!audio.canPlayType('audio/wav').replace(/no/, ''),
                    m4a: !!audio.canPlayType('audio/mp4').replace(/no/, ''),
                    ogg: !!audio.canPlayType('audio/ogg').replace(/no/, ''),
                    webm: !!audio.canPlayType('audio/webm').replace(/no/, '')
                };
            }

            handleAudioError(soundName, sound) {
                console.error(`üîç Debugging ${soundName} audio error:`);
                const sources = sound.getElementsByTagName('source');
                Array.from(sources).forEach(source => {
                    console.log(`- Trying to load: ${source.src}`);
                    // Try to fetch the file to check if it exists
                    fetch(source.src)
                        .then(response => {
                            if (!response.ok) throw new Error(`HTTP ${response.status}`);
                            console.log(`‚úÖ ${source.src} is accessible`);
                        })
                        .catch(error => console.error(`‚ùå ${source.src} is not accessible:`, error));
                });
            }
            
            testAudioElements() {
                console.log('üîç Testing audio elements...');
                // Preload all audio files
                const preloadPromises = [];
                
                Object.entries(this.sounds).forEach(([soundName, sound]) => {
                    if (!sound) {
                        console.error(`‚ùå Audio element not found: ${soundName}`);
                        return;
                    }

                    // Create a promise for this sound's loading
                    const loadPromise = new Promise((resolve) => {
                        const loadHandler = () => {
                            sound.removeEventListener('canplaythrough', loadHandler);
                            sound.removeEventListener('error', errorHandler);
                            console.log(`‚úÖ ${soundName}: Ready`);
                            resolve();
                        };
                        const errorHandler = () => {
                            sound.removeEventListener('canplaythrough', loadHandler);
                            sound.removeEventListener('error', errorHandler);
                            console.warn(`‚ö†Ô∏è ${soundName}: Failed to load`);
                            resolve(); // Resolve anyway to not block other sounds
                        };
                        
                        sound.addEventListener('canplaythrough', loadHandler);
                        sound.addEventListener('error', errorHandler);
                        sound.load();
                    });
                    
                    preloadPromises.push(loadPromise);
                });

                // Also preload background music
                if (this.bgMusic) {
                    const bgMusicPromise = new Promise((resolve) => {
                        const loadHandler = () => {
                            this.bgMusic.removeEventListener('canplaythrough', loadHandler);
                            this.bgMusic.removeEventListener('error', errorHandler);
                            console.log('‚úÖ Background music: Ready');
                            resolve();
                        };
                        const errorHandler = () => {
                            this.bgMusic.removeEventListener('canplaythrough', loadHandler);
                            this.bgMusic.removeEventListener('error', errorHandler);
                            console.warn('‚ö†Ô∏è Background music: Failed to load');
                            resolve();
                        };
                        
                        this.bgMusic.addEventListener('canplaythrough', loadHandler);
                        this.bgMusic.addEventListener('error', errorHandler);
                        this.bgMusic.load();
                    });
                    preloadPromises.push(bgMusicPromise);
                }

                // Wait for all sounds to either load or fail
                Promise.all(preloadPromises).then(() => {
                    console.log('üéµ Audio system initialization complete');
                });
            }
            
            handleAudioError(soundName, audioElement) {
                console.log(`üîÑ Attempting to recover ${soundName} audio...`);
                
                // Try to reload the audio element
                setTimeout(() => {
                    try {
                        audioElement.load();
                    } catch (error) {
                        console.error(`Failed to reload ${soundName}:`, error);
                    }
                }, 1000);
            }
            

            
            setupAutoPlay() {
                // Start music on first user interaction (required by browsers)
                const startMusic = () => {
                    console.log('üéµ Starting music on user interaction');
                    if (!this.musicStarted && this.musicEnabled) {
                        this.playBackgroundMusic();
                        this.musicStarted = true;
                    }
                    document.removeEventListener('click', startMusic);
                    document.removeEventListener('keydown', startMusic);
                    document.removeEventListener('touchstart', startMusic);
                };
                
                // Listen for any user interaction
                document.addEventListener('click', startMusic);
                document.addEventListener('keydown', startMusic);
                document.addEventListener('touchstart', startMusic);
                
                console.log('üéµ Audio system ready - music will start on first user interaction');
            }
            
            async playSound(soundName, volume = 1) {
                if (!this.sfxEnabled) return;
                
                const sound = this.sounds[soundName];
                if (!sound) {
                    console.warn(`‚ö†Ô∏è Sound '${soundName}' not found`);
                    return;
                }

                // If sound is already playing, stop it first
                if (!sound.paused) {
                    sound.pause();
                    sound.currentTime = 0;
                }

                // Set the volume before playing
                sound.volume = Math.min(Math.max(this.volume * volume, 0), 1);

                try {
                    // If the audio isn't loaded yet, wait for it
                    if (sound.readyState < 2) { // HAVE_CURRENT_DATA
                        await new Promise((resolve, reject) => {
                            const loadHandler = () => {
                                sound.removeEventListener('canplaythrough', loadHandler);
                                sound.removeEventListener('error', errorHandler);
                                resolve();
                            };
                            const errorHandler = (error) => {
                                sound.removeEventListener('canplaythrough', loadHandler);
                                sound.removeEventListener('error', errorHandler);
                                reject(error);
                            };
                            sound.addEventListener('canplaythrough', loadHandler);
                            sound.addEventListener('error', errorHandler);
                            sound.load();
                        });
                    }

                    // Play the sound
                    await sound.play();
                } catch (error) {
                    console.warn(`üîá Could not play ${soundName}:`, error);
                    // Don't retry - just let it fail silently
                }
            }
            
            handlePlaybackError(soundName, sound) {
                console.log(`üîÑ Attempting to recover ${soundName} playback...`);
                
                // Try to reload and play again
                setTimeout(() => {
                    try {
                        sound.load();
                        setTimeout(() => {
                            if (sound.readyState >= 2) {
                                sound.play().catch(e => {
                                    console.log(`üîá ${soundName} playback recovery failed:`, e.message);
                                });
                            }
                        }, 500);
                    } catch (error) {
                        console.error(`Failed to recover ${soundName}:`, error);
                    }
                }, 100);
            }
            
            playBackgroundMusic() {
                if (this.musicEnabled && this.bgMusic) {
                    try {
                        console.log('üé∂ Starting background music');
                        this.bgMusic.volume = this.volume * 0.3;
                        this.bgMusic.play().then(() => {
                            console.log('‚úÖ Background music started successfully');
                            this.updateMusicButton();
                            
                            // Hide start music button
                            const startBtn = document.getElementById('startMusicBtn');
                            if (startBtn) {
                                startBtn.style.display = 'none';
                            }
                            
                            // Show success message
                            setTimeout(() => {
                                if (typeof showMessage === 'function') {
                                    showMessage('üéµ Background music started!', 'success');
                                }
                            }, 500);
                        }).catch(error => {
                            console.error('‚ùå Error playing background music:', error);
                        });
                    } catch (error) {
                        console.error('‚ùå Error starting background music:', error);
                    }
                }
            }
            
            stopBackgroundMusic() {
                if (this.bgMusic) {
                    console.log('üîá Stopping background music');
                    this.bgMusic.pause();
                    this.bgMusic.currentTime = 0;
                    this.updateMusicButton();
                }
            }
            
            toggleMusic() {
                this.musicEnabled = !this.musicEnabled;
                
                if (this.musicEnabled) {
                    this.playBackgroundMusic();
                } else {
                    this.stopBackgroundMusic();
                }
                
                // Update all UI elements
                const musicToggle = document.getElementById('musicToggle');
                const musicToggleModal = document.getElementById('musicToggleModal');
                
                if (musicToggle) {
                    musicToggle.classList.toggle('muted', !this.musicEnabled);
                }
                if (musicToggleModal) {
                    musicToggleModal.checked = this.musicEnabled;
                }
            }
            
            toggleSFX() {
                this.sfxEnabled = !this.sfxEnabled;
                
                // Update all UI elements
                const sfxToggle = document.getElementById('sfxToggle');
                const sfxToggleModal = document.getElementById('sfxToggleModal');
                
                if (sfxToggle) {
                    sfxToggle.classList.toggle('muted', !this.sfxEnabled);
                }
                if (sfxToggleModal) {
                    sfxToggleModal.checked = this.sfxEnabled;
                }
                
                // Play test sound when enabling
                if (this.sfxEnabled) {
                    this.playSound('buttonClick');
                }
            }
            
            setVolume(volume) {
                this.volume = volume / 100;
                this.updateVolumes();
            }
            
            updateVolumes() {
                // Update background music volume
                if (this.bgMusic) {
                    this.bgMusic.volume = this.volume * 0.3;
                }
                
                // Update all sound effects volumes
                Object.values(this.sounds).forEach(sound => {
                    if (sound) {
                        sound.volume = this.volume;
                    }
                });
            }
            
            updateMusicButton() {
                const button = document.getElementById('musicToggle');
                const status = document.getElementById('musicStatus');
                if (button && status) {
                    status.textContent = this.musicEnabled ? 'ON' : 'OFF';
                    button.classList.toggle('muted', !this.musicEnabled);
                }
            }
            
            updateSFXButton() {
                const button = document.getElementById('sfxToggle');
                const status = document.getElementById('sfxStatus');
                if (button && status) {
                    status.textContent = this.sfxEnabled ? 'ON' : 'OFF';
                    button.classList.toggle('muted', !this.sfxEnabled);
                }
            }
            
            // Test all audio files to check format compatibility
            testAllAudio() {
                console.log('üß™ Testing all audio files...');
                
                const testResults = {
                    backgroundMusic: false,
                    soundEffects: {}
                };
                
                // Test background music
                if (this.bgMusic && this.bgMusic.readyState >= 2) {
                    testResults.backgroundMusic = true;
                    console.log('‚úÖ Background music: Ready');
                } else {
                    console.log('‚ùå Background music: Not ready');
                }
                
                // Test all sound effects
                Object.keys(this.sounds).forEach(soundName => {
                    const sound = this.sounds[soundName];
                    if (sound && sound.readyState >= 2) {
                        testResults.soundEffects[soundName] = true;
                        console.log(`‚úÖ ${soundName}: Ready`);
                    } else {
                        testResults.soundEffects[soundName] = false;
                        console.log(`‚ùå ${soundName}: Not ready`);
                    }
                });
                
                // Show summary
                const totalSounds = Object.keys(this.sounds).length + 1; // +1 for bg music
                const readySounds = (testResults.backgroundMusic ? 1 : 0) + 
                    Object.values(testResults.soundEffects).filter(ready => ready).length;
                
                console.log(`üéµ Audio Test Results: ${readySounds}/${totalSounds} audio files ready`);
                
                if (readySounds === totalSounds) {
                    console.log('üéâ All audio files are working perfectly!');
                } else {
                    console.log('‚ö†Ô∏è Some audio files may need format conversion or re-encoding');
                }
                
                return testResults;
            }
        }

        // Global audio manager instance
        let audioManager;
        
        // Audio control functions
        function startMusicManually() {
            console.log('üéµ Manual music start requested');
            audioManager?.playSound('buttonClick');
            audioManager?.playBackgroundMusic();
        }
        
        function toggleMusic() {
            audioManager?.playSound('buttonClick');
            audioManager?.toggleMusic();
        }
        
        function toggleSFX() {
            if (audioManager?.sfxEnabled) {
                audioManager.playSound('buttonClick');
            }
            audioManager?.toggleSFX();
        }
        
        function setVolume(volume) {
            audioManager?.setVolume(volume);
        }

        // Debug function to test all audio files (call from browser console)
        function testAudio() {
            if (audioManager) {
                console.log('üéµ Running manual audio test...');
                const results = audioManager.testAllAudio();
                updateAudioStatusDisplay(results);
                
                // Test each sound effect
                Object.keys(audioManager.sounds).forEach((soundName, index) => {
                    setTimeout(() => {
                        console.log(`üéµ Testing ${soundName}...`);
                        audioManager.playSound(soundName, 0.5);
                    }, index * 1000);
                });
                
                return results;
            } else {
                console.log('‚ùå Audio manager not initialized');
                return null;
            }
        }

        // Manual audio test function for the settings button
        function testAudioManual() {
            audioManager?.playSound('buttonClick');
            
            if (audioManager) {
                const results = audioManager.testAllAudio();
                updateAudioStatusDisplay(results);
                
                // Play a sample of each sound
                Object.keys(audioManager.sounds).forEach((soundName, index) => {
                    setTimeout(() => {
                        audioManager.playSound(soundName, 0.3);
                    }, index * 800);
                });
                
                showMessage('üéµ Audio test complete! Check settings for results.', 'info');
            }
        }

        // Update the audio status display in settings - DISABLED
        function updateAudioStatusDisplay(results = null) {
            return; // Audio status section removed
            const audioStatus = document.getElementById('audioStatus');
            if (!audioStatus || !audioManager) return;
            
            // Get results if not provided
            if (!results) {
                results = audioManager.testAllAudio();
            }
            
            let html = '';
            
            // Background Music Status
            const bgStatus = results.backgroundMusic ? 
                '<span class="status">‚úÖ Ready</span>' : 
                '<span class="status">‚ùå Not Ready</span>';
            html += `<div class="audio-item ${results.backgroundMusic ? 'ready' : 'not-ready'}">
                <span>üé∂ Background Music</span>
                ${bgStatus}
            </div>`;
            
            // Sound Effects Status
            const soundNames = {
                cardFlip: 'üÇ† Card Flip',
                cardPlace: 'üéØ Card Place', 
                peakCard: '‚ö° Peak Card',
                winSound: 'üèÜ Win Sound',
                loseSound: 'üíî Lose Sound',
                buttonClick: 'üîò Button Click'
                // turnNotification removed - file not available
            };
            
            Object.keys(results.soundEffects).forEach(soundName => {
                const isReady = results.soundEffects[soundName];
                const displayName = soundNames[soundName] || soundName;
                const status = isReady ? 
                    '<span class="status">‚úÖ Ready</span>' : 
                    '<span class="status">‚ùå Not Ready</span>';
                
                html += `<div class="audio-item ${isReady ? 'ready' : 'not-ready'}">
                    <span>${displayName}</span>
                    ${status}
                </div>`;
            });
            
            // Summary
            const totalSounds = Object.keys(results.soundEffects).length + 1;
            const readySounds = (results.backgroundMusic ? 1 : 0) + 
                Object.values(results.soundEffects).filter(ready => ready).length;
            
            if (readySounds === totalSounds) {
                html += '<div style="margin-top: 10px; text-align: center; color: #27ae60; font-weight: bold;">üéâ All audio files working!</div>';
            } else {
                html += `<div style="margin-top: 10px; text-align: center; color: #e74c3c; font-weight: bold;">‚ö†Ô∏è ${totalSounds - readySounds} audio files need attention</div>`;
            }
            
            audioStatus.innerHTML = html;
        }

        // Settings Modal Functions
        function openSettings() {
            audioManager?.playSound('buttonClick');
            const modal = document.getElementById('settingsModal');
            modal.style.display = 'block';
            
            // Sync settings with current audio manager state
            syncSettingsWithAudioManager();
            
            // Update audio status display
            setTimeout(() => {
                updateAudioStatusDisplay();
            }, 100);
        }
        
        function closeSettings() {
            audioManager?.playSound('buttonClick');
            const modal = document.getElementById('settingsModal');
            modal.style.display = 'none';
        }
        
        function syncSettingsWithAudioManager() {
            if (!audioManager) return;
            
            const musicToggle = document.getElementById('musicToggleModal');
            const sfxToggle = document.getElementById('sfxToggleModal');
            const volumeSlider = document.getElementById('volumeSliderModal');
            const volumePercent = document.getElementById('volumePercent');
            
            if (musicToggle) musicToggle.checked = audioManager.musicEnabled;
            if (sfxToggle) sfxToggle.checked = audioManager.sfxEnabled;
            
            if (volumeSlider && volumePercent) {
                const volume = Math.round(audioManager.volume * 100);
                volumeSlider.value = volume;
                volumePercent.textContent = volume + '%';
            }
        }
        
        function toggleMusicFromSettings() {
            if (!audioManager) return;
            audioManager.toggleMusic();
        }
        
        function toggleSFXFromSettings() {
            if (!audioManager) return;
            audioManager.toggleSFX();
        }
        
        function setVolumeFromSettings(volume) {
            const volumePercent = Math.round(volume);
            document.getElementById('volumePercent').textContent = volumePercent + '%';
            audioManager?.setVolume(volume);
        }
        
        function clearCacheFromSettings() {
            const confirmed = confirm('üßπ Clear all game cache?\n\nThis will clear stored game data and service worker caches.\nThe page will refresh automatically.\n\nContinue?');
            if (confirmed) {
                fullCacheClear();
            }
        }

        // Initialize audio system when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Check and clear cache if app version changed
            checkAndClearCacheIfNeeded();
            
            audioManager = new AudioManager();
            
            // Test all audio files after a brief delay to allow loading
            setTimeout(() => {
                const results = audioManager.testAllAudio();
                updateAudioStatusDisplay(results);
            }, 2000);
            
            // Initialize player count button handlers
            initPlayerCountButtons();
            
            // Show start music button initially
            setTimeout(() => {
                const startBtn = document.getElementById('startMusicBtn');
                if (startBtn) {
                    startBtn.style.display = 'inline-flex';
                }
            }, 1000);
        });

        // Register Service Worker for PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js').then((registration) => {
                    console.log('‚úÖ Service Worker registered successfully');
                }).catch((error) => {
                    console.log('‚ö†Ô∏è Service Worker registration failed:', error);
                });
            });
        }

        // Export game functions and classes to window for external scripts
        console.log('[Game Engine] Exporting game functions to window object...');
        window.Player = Player;
        window.Card = Card;
        window.CardType = CardType;
        console.log('[Game Engine] Game functions exported. Available on window:');
        console.log('  - Player:', typeof window.Player);
        console.log('  - Card:', typeof window.Card);
        console.log('  - CardType:', typeof window.CardType);
        console.log('  - createDeck:', typeof window.createDeck);
        console.log('  - dealCards:', typeof window.dealCards);
    </script>

    <!-- Online Multiplayer Scripts -->
    <script src="js/matchmaking.js"></script>
    <script src="js/multiplayerGame.js"></script>
    <script src="js/onlineController.js"></script>

    <!-- Online Game Functions -->
    <script>
        /**
         * Start local game mode
         */
        function startLocalGame() {
            document.getElementById('playerCountSection').style.display = 'block';
            document.getElementById('onlinePlayerCountSection').style.display = 'none';
            document.getElementById('gameTypeSection').style.display = 'none';
        }

        /**
         * Start online game mode
         */
        async function startOnlineMode() {
            // Check if player has entered a name
            const playerNameInput = document.getElementById('playerName');
            const playerName = playerNameInput.value.trim();
            
            if (!playerName) {
                alert('Please enter your name before playing online!');
                playerNameInput.focus();
                return;
            }

            if (!onlineController) {
                alert('Online mode is loading. Please wait and try again.');
                return;
            }

            try {
                // Store the player name in game session
                gameSession.playerName = playerName;
                
                const result = await onlineController.initializeOnlineMode();
                if (result.success) {
                    console.log('Online mode initialized with player ID:', result.playerId);
                    console.log('Player name:', playerName);
                    document.getElementById('gameTypeSection').style.display = 'none';
                    document.getElementById('playerCountSection').style.display = 'none';
                    document.getElementById('onlinePlayerCountSection').style.display = 'block';
                    
                    // Re-initialize button handlers for online buttons
                    initPlayerCountButtons();
                } else {
                    alert('Failed to initialize online mode: ' + result.error);
                }
            } catch (error) {
                console.error('Error starting online mode:', error);
                alert('Error starting online mode: ' + error.message);
            }
        }

        /**
         * Join online queue for specified player count
         */
        async function joinOnlineQueue(playerCount) {
            try {
                if (!onlineController) {
                    alert('Online mode is not available');
                    return;
                }

                // Hide all selection sections
                document.getElementById('gameTypeSection').style.display = 'none';
                document.getElementById('playerCountSection').style.display = 'none';
                document.getElementById('onlinePlayerCountSection').style.display = 'none';
                document.getElementById('startScreen').style.display = 'none';

                console.log('Joining queue for', playerCount, 'players');
                await onlineController.findMatch(playerCount);
            } catch (error) {
                console.error('Error joining queue:', error);
                alert('Error joining queue: ' + error.message);
                // Show sections again on error
                document.getElementById('startScreen').style.display = 'block';
                document.getElementById('gameTypeSection').style.display = 'block';
                document.getElementById('onlinePlayerCountSection').style.display = 'block';
            }
        }

        /**
         * Update online game UI when game state changes
         */
        function updateOnlineGameUI(gameState) {
            console.log('Updating online game UI:', gameState);
            // This function will be called by the online controller when game state updates
            // You can update player positions, cards, turn indicator, etc.
        }

        /**
         * Handle remote card plays
         */
        function onRemoteCardPlayed(playData) {
            console.log('Remote card played:', playData);
            // Handle displaying cards played by other players
        }

        // Back button handler
        function backToGameMode() {
            document.getElementById('gameTypeSection').style.display = 'block';
            document.getElementById('playerCountSection').style.display = 'none';
            document.getElementById('onlinePlayerCountSection').style.display = 'none';
        }
    </script>

    <!-- Footer with Privacy Policy -->
    <footer>
        Peak Card Game - A multiplayer card game | 
        <a href="/privacy-policy.html" target="_blank">Privacy Policy</a> | 
        <a href="https://github.com/enochaseks/peakgame" target="_blank">GitHub</a>
    </footer>
</body>
</html>