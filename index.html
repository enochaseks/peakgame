<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Peak Card Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 25%, #f093fb 50%, #f5576c 75%, #4facfe 100%);
            background-size: 400% 400%;
            animation: gradientBg 15s ease infinite;
            min-height: 100vh;
            color: #333;
        }

        @keyframes gradientBg {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .game-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .game-header {
            text-align: center;
            margin-bottom: 40px;
            position: relative;
            overflow: hidden;
        }

        .sparkle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #fff;
            border-radius: 50%;
            animation: sparkle 2s linear infinite;
            box-shadow: 0 0 6px #fff;
        }

        @keyframes sparkle {
            0% { opacity: 0; transform: translateY(0px) scale(0); }
            50% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: translateY(-100px) scale(0); }
        }

        .sparkle:nth-child(1) { left: 20%; animation-delay: 0s; }
        .sparkle:nth-child(2) { left: 40%; animation-delay: 0.5s; }
        .sparkle:nth-child(3) { left: 60%; animation-delay: 1s; }
        .sparkle:nth-child(4) { left: 80%; animation-delay: 1.5s; }

        .game-title {
            position: relative;
            font-size: 5em;
            font-weight: 900;
            margin-bottom: 30px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.7);
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #feca57, #ff9ff3);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease-in-out infinite;
            letter-spacing: 0.1em;
            z-index: 10;
            position: relative;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .title-container {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
        }

        .title-card {
            position: absolute;
            width: 80px;
            height: 120px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.5em;
            border: 3px solid #333;
            box-shadow: 0 6px 12px rgba(0,0,0,0.3);
            animation: floatCard 4s ease-in-out infinite;
            z-index: 1;
        }

        .title-card:nth-child(1) {
            left: -100px;
            top: 20px;
            background: linear-gradient(145deg, #ff6b6b, #ee5a24);
            color: white;
            animation-delay: 0s;
            transform: rotate(-15deg);
        }

        .title-card:nth-child(2) {
            left: 50%;
            top: -30px;
            transform: translateX(-50%) rotate(5deg);
            background: linear-gradient(145deg, #9b59b6, #8e44ad);
            color: white;
            animation-delay: 1s;
        }

        .title-card:nth-child(3) {
            right: -100px;
            top: 25px;
            background: linear-gradient(145deg, #4ecdc4, #26d0ce);
            color: white;
            animation-delay: 2s;
            transform: rotate(12deg);
        }

        @keyframes floatCard {
            0%, 100% { transform: translateY(0px) rotate(var(--rotation, 0deg)); }
            50% { transform: translateY(-10px) rotate(var(--rotation, 0deg)); }
        }

        .title-card:nth-child(1) { --rotation: -15deg; }
        .title-card:nth-child(2) { --rotation: 5deg; }
        .title-card:nth-child(3) { --rotation: 12deg; }

        .game-info {
            background: rgba(255,255,255,0.9);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        /* Floating game messages overlay: keep messages above all table elements */
        #gameMessages {
            position: fixed;
            top: 110px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 99999;
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: none; /* allow clicks through unless child enables pointer events */
            width: auto;
            max-width: 90%;
            align-items: center;
        }

        .game-message {
            pointer-events: auto; /* allow interaction with message (if needed) */
            min-width: 220px;
            max-width: 640px;
            text-align: center;
            border-radius: 10px;
            padding: 10px 14px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.25);
        }

        .info-item {
            text-align: center;
        }

        .info-label {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
        }

        .game-table {
            position: relative;
            width: 400px;
            height: 400px;
            margin: 0 auto 30px;
            background: radial-gradient(circle, #2d5016 0%, #1a3009 70%);
            border-radius: 50%;
            border: 12px solid #8B4513;
            box-shadow: 
                0 0 25px rgba(0,0,0,0.5),
                inset 0 0 40px rgba(0,0,0,0.3),
                inset 0 0 80px rgba(139, 69, 19, 0.2);
        }

        .game-table::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 120px;
            height: 120px;
            background: radial-gradient(circle, #1a3009 0%, #0f1a05 100%);
            border-radius: 50%;
            border: 2px solid rgba(139, 69, 19, 0.5);
        }

        .players-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .player-seat {
            position: absolute;
            width: 140px;
            transform-origin: center;
        }

        .player-seat:nth-child(1) {
            top: -70px;
            left: 50%;
            transform: translateX(-50%);
        }

        .player-seat:nth-child(2) {
            top: 50%;
            right: -70px;
            transform: translateY(-50%);
        }

        .player-seat:nth-child(3) {
            bottom: -70px;
            left: 50%;
            transform: translateX(-50%);
        }

        .player-seat:nth-child(4) {
            top: 50%;
            left: -70px;
            transform: translateY(-50%);
        }

        .player-avatar {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            padding: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            border: 2px solid transparent;
            backdrop-filter: blur(10px);
            max-width: 130px;
        }

        .player-avatar.current-turn {
            border: 2px solid #4CAF50;
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.6);
            transform: scale(1.02);
            background: rgba(76, 175, 80, 0.1);
        }

        .player-avatar.disqualified {
            opacity: 0.6;
            border: 2px solid #f44336;
            background: rgba(244, 67, 54, 0.1);
        }

        .player-avatar.finished {
            border: 2px solid #FFD700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
            background: rgba(255, 215, 0, 0.1);
        }

        .avatar-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3em;
            margin-bottom: 5px;
            border: 2px solid #333;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .avatar-icon:nth-child(1) { background: linear-gradient(135deg, #ff9a9e, #fecfef); }
        .avatar-icon:nth-child(2) { background: linear-gradient(135deg, #a8edea, #fed6e3); }
        .avatar-icon:nth-child(3) { background: linear-gradient(135deg, #fbc2eb, #a6c1ee); }
        .avatar-icon:nth-child(4) { background: linear-gradient(135deg, #74b9ff, #0984e3); }

        .player-name {
            font-size: 0.9em;
            font-weight: bold;
            margin-bottom: 3px;
            text-align: center;
            color: #333;
        }

        .player-status {
            font-size: 0.8em;
            padding: 4px 8px;
            border-radius: 12px;
            color: white;
        }

        .status-active { background: #4CAF50; }
        .status-disqualified { background: #f44336; }
        .status-finished { background: #FFD700; color: #333; }

        .player-hand {
            display: flex;
            flex-wrap: wrap;
            gap: 2px;
            margin-top: 5px;
            justify-content: center;
            max-width: 120px;
        }

        .player-seat .card {
            width: 22px;
            height: 32px;
            font-size: 0.6em;
        }

        .card-count {
            font-size: 0.8em;
            color: #666;
            text-align: center;
            margin-bottom: 3px;
        }

        .card {
            width: 60px;
            height: 90px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid #333;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .card.regular {
            background: linear-gradient(145deg, #ffffff, #f0f0f0);
            color: #333;
        }

        .card.peak {
            background: linear-gradient(145deg, #ff6b6b, #ee5a24);
            color: white;
            font-size: 0.8em;
        }

        .card.reverse {
            background: linear-gradient(145deg, #9b59b6, #8e44ad);
            color: white;
            font-size: 0.7em;
            position: relative;
        }

        .card.reverse:before {
            content: 'üîÑ';
            position: absolute;
            top: 5px;
            left: 5px;
            font-size: 0.6em;
        }

        .card.star {
            background: linear-gradient(145deg, #00b894, #00a085);
            color: white;
            font-size: 0.7em;
            position: relative;
        }

        .card.star:before {
            content: '‚ú®';
            position: absolute;
            top: 5px;
            left: 5px;
            font-size: 0.6em;
        }

        .card.goblin {
            background: linear-gradient(145deg, #6c5ce7, #5f3dc4);
            color: white;
            font-size: 0.7em;
            position: relative;
        }

        .card.goblin:before {
            content: 'üëπ';
            position: absolute;
            top: 5px;
            left: 5px;
            font-size: 0.6em;
        }

        .card.pause {
            background: linear-gradient(145deg, #fdcb6e, #e17055);
            color: white;
            font-size: 0.7em;
            position: relative;
        }

        .card.pause:before {
            content: '‚è∏Ô∏è';
            position: absolute;
            top: 5px;
            left: 5px;
            font-size: 0.6em;
        }

        .card.card-back {
            background: linear-gradient(145deg, #2c2c2c, #1a1a1a) !important;
            color: #666 !important;
            border: 2px solid #444;
            cursor: default !important;
        }

        .card.card-back:hover {
            transform: none !important;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2) !important;
        }

        .card.playable {
            border-color: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        .card.last-played {
            border-color: #2196F3;
            box-shadow: 0 0 15px rgba(33, 150, 243, 0.6);
            transform: scale(1.1);
        }

        .table-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 10;
        }

        .discard-pile-center {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .discard-label {
            color: #fff;
            font-size: 1em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            font-weight: bold;
            background: rgba(0,0,0,0.3);
            padding: 5px 10px;
            border-radius: 15px;
            backdrop-filter: blur(5px);
        }

        .controls {
            background: rgba(255,255,255,0.95);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .btn {
            background: linear-gradient(145deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 12px 24px;
            margin: 5px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn.draw { background: linear-gradient(145deg, #2196F3, #1976D2); }
        .btn.quit { background: linear-gradient(145deg, #f44336, #d32f2f); }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
        }

        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            min-width: 400px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .setup-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .player-input {
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
        }

        .player-input:focus {
            border-color: #4CAF50;
            outline: none;
        }

        .game-message {
            background: rgba(255,255,255,0.9);
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            text-align: center;
            font-weight: bold;
        }

        .message-info { border-left: 4px solid #2196F3; }
        .message-success { border-left: 4px solid #4CAF50; }
        .message-warning { border-left: 4px solid #ff9800; }
        .message-error { border-left: 4px solid #f44336; }

        .rules-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.9);
            border: none;
            padding: 10px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 1em;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .rules-panel {
            display: none;
            position: fixed;
            top: 70px;
            right: 20px;
            background: white;
            padding: 20px;
            border-radius: 15px;
            max-width: 300px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            z-index: 100;
        }

        .rules-panel h3 {
            color: #4CAF50;
            margin-bottom: 10px;
        }

        .rules-panel ul {
            list-style-type: none;
            padding-left: 0;
        }

        .rules-panel li {
            padding: 5px 0;
            border-bottom: 1px solid #eee;
        }

        @media (max-width: 768px) {
            .game-table {
                width: 380px;
                height: 380px;
            }
            
            .player-seat {
                width: 110px;
            }
            
            .player-seat:nth-child(1) { top: -60px; }
            .player-seat:nth-child(2) { right: -60px; }
            .player-seat:nth-child(3) { bottom: -60px; }
            .player-seat:nth-child(4) { left: -60px; }
            
            .avatar-icon {
                width: 32px;
                height: 32px;
                font-size: 1.1em;
            }
            
            .player-seat .card {
                width: 18px;
                height: 26px;
                font-size: 0.5em;
            }
            
            .player-avatar {
                padding: 8px;
                max-width: 100px;
            }
            
            .game-info {
                flex-direction: column;
                gap: 15px;
            }
            
            .game-title {
                font-size: 3.5em;
            }
            
            .title-card {
                width: 60px;
                height: 90px;
                font-size: 1.2em;
            }
        }
    </style>
</head>
<body>
    <button class="rules-toggle" onclick="toggleRules()">üìñ Rules</button>
    
    <div class="rules-panel" id="rulesPanel">
        <h3>Peak Card Game Rules</h3>
        <ul>
            <li><strong>Players:</strong> Exactly 4 players</li>
            <li><strong>Starting Cards:</strong> 7 per player</li>
            <li><strong>Cannot finish on:</strong> Cards 1-4, Peak, Reverse, Star, Goblin, Pause</li>
            <li><strong>Can finish on:</strong> Cards 5-6</li>
            <li><strong>Can finish on 8-10:</strong> Only if high card played this round</li>
            <li><strong>Peak cards:</strong> ‚õ∞Ô∏è Next player draws 5 cards</li>
            <li><strong>Reverse cards:</strong> üîÑ Changes play direction</li>
            <li><strong>Star cards:</strong> ‚ú® Removes all Peak cards from other players</li>
            <li><strong>Goblin cards:</strong> üëπ Gives bad cards (1-4) to all other players</li>
            <li><strong>Pause cards:</strong> ‚è∏Ô∏è Pauses another player for 2 minutes</li>
            <li><strong>Disqualified:</strong> Over 20 cards</li>
            <li><strong>Winner:</strong> Last player standing</li>
        </ul>
    </div>

    <div class="game-container">
        <div class="game-header">
            <div class="sparkle"></div>
            <div class="sparkle"></div>
            <div class="sparkle"></div>
            <div class="sparkle"></div>
            <div class="title-container">
                <div class="title-card">Peak</div>
                <div class="title-card">üîÑ</div>
                <div class="title-card">10</div>
                <h1 class="game-title">PEAK</h1>
            </div>
        </div>

        <div class="game-info">
            <div class="info-item">
                <div class="info-label">Round</div>
                <div class="info-value" id="roundNumber">1</div>
            </div>
            <div class="info-item">
                <div class="info-label">Cards in Deck</div>
                <div class="info-value" id="deckCount">58</div>
            </div>
            <div class="info-item">
                <div class="info-label">High Card Played</div>
                <div class="info-value" id="highCardPlayed">‚ùå</div>
            </div>
            <div class="info-item">
                <div class="info-label">Current Player</div>
                <div class="info-value" id="currentPlayer">-</div>
            </div>
            <div class="info-item">
                <div class="info-label">Direction</div>
                <div class="info-value" id="gameDirection">üîÑ</div>
            </div>
        </div>

        <div id="gameMessages"></div>

        <div class="game-table">
            <div class="players-container" id="playersContainer">
                <!-- Players will be generated here -->
            </div>
            <div class="table-center">
                <div class="discard-pile-center">
                    <div class="discard-label">Last Played</div>
                    <div id="lastPlayedCard">
                        <div class="card regular" style="margin: 0 auto; background: #ddd; color: #666;">No Card Yet</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="controls">
            <button class="btn" id="drawBtn" onclick="console.log('üñ±Ô∏è Draw button clicked'); drawCard()" disabled>üÉè Draw Card</button>
            <button class="btn quit" onclick="showSetup()">üîÑ New Game</button>
            <button class="btn" onclick="showGameState()">üìä Game State</button>
        </div>
    </div>

    <!-- Setup Modal -->
    <div class="modal" id="setupModal">
        <div class="modal-content">
            <h2>üèîÔ∏è Peak Card Game</h2>
            <div id="startScreen" class="setup-form">
                <p>Enter your name:</p>
                <input type="text" class="player-input" id="playerName" placeholder="Your Name" maxlength="20">
                <p style="margin-top: 20px;">Game PIN:</p>
                <input type="text" class="player-input" id="gamePin" placeholder="Enter 4-digit PIN" maxlength="4" pattern="[0-9]{4}">
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="btn" onclick="createGame()" style="flex: 1;">üéÆ Create Game</button>
                    <button class="btn" onclick="joinGame()" id="joinBtn" disabled style="flex: 1;">üö™ Join Game</button>
                </div>
            </div>
            
            <div id="lobbyScreen" class="setup-form" style="display: none;">
                <h3 id="lobbyTitle">Game Lobby</h3>
                <div id="gamePinDisplay" style="font-size: 2em; font-weight: bold; color: #4CAF50; margin: 10px 0;"></div>
                <p>üåç Share this PIN with friends anywhere in the world!</p>
                <div id="shareableLink" style="margin: 10px 0; padding: 10px; background: #f0f0f0; border-radius: 5px; font-size: 0.9em;">
                    <strong>üîó Quick Share Link:</strong><br>
                    <span id="shareUrl" style="color: #2196F3; word-break: break-all;"></span><br>
                    <button onclick="copyShareLink()" style="margin-top: 5px; padding: 5px 10px; background: #2196F3; color: white; border: none; border-radius: 3px; cursor: pointer;">üìã Copy Link</button>
                </div>
                <p style="font-size: 0.9em; color: #666;">‚úÖ <strong>Now powered by Firebase</strong> - Friends can join from any device worldwide!</p>
                <div id="playersList" style="margin: 20px 0; text-align: left;">
                    <h4>Players Joined:</h4>
                    <ul id="playersUL" style="list-style: none; padding: 0;"></ul>
                </div>
                <div id="waitingMessage" style="color: #666; margin: 10px 0;">Waiting for players...</div>
                <button class="btn" onclick="startGameFromLobby()" id="startGameBtn" disabled style="margin-top: 20px;">üöÄ Start Game</button>
                <button class="btn quit" onclick="leaveLobby()" style="margin-top: 10px;">üö™ Leave Lobby</button>
            </div>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div class="modal" id="gameOverModal">
        <div class="modal-content">
            <h2 id="gameOverTitle">üéâ Game Over!</h2>
            <p id="gameOverMessage"></p>
            <button class="btn" onclick="showSetup()">üîÑ Play Again</button>
        </div>
    </div>

    <script>
        // Game state
        let game = {
            players: [],
            deck: [],
            discardPile: [],
            currentPlayerIndex: 0,
            roundNumber: 1,
            highCardPlayedThisRound: false,
            gameOver: false,
            winner: null,
            direction: 1  // 1 for clockwise, -1 for counter-clockwise
        };

        // Multiplayer state
        let gameSession = {
            pin: null,
            isHost: false,
            playerName: '',
            playerId: null,
            lobbyPlayers: [],
            gameStarted: false
        };

        // Firebase Realtime Database for true cross-device multiplayer
        const FIREBASE_URL = 'https://peakgame-19c4e-default-rtdb.europe-west1.firebasedatabase.app';

        async function saveGameToCloud(pin, gameData) {
            try {
                const response = await fetch(`${FIREBASE_URL}/games/${pin}.json`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(gameData)
                });
                
                if (response.ok) {
                    console.log('‚úÖ Game saved to Firebase:', pin);
                    return true;
                } else {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
            } catch (error) {
                console.error('‚ùå Error saving to Firebase:', error);
                alert('Error connecting to game server. Please check your internet connection.');
                return false;
            }
        }

        // Save the ENTIRE game state to Firebase (not just lobby)
        async function saveGameStateToCloud(pin, gameState) {
            try {
                const response = await fetch(`${FIREBASE_URL}/games/${pin}/gameState.json`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(gameState)
                });
                
                if (response.ok) {
                    console.log('‚úÖ Game state saved to Firebase:', pin);
                    return true;
                } else {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
            } catch (error) {
                console.error('‚ùå Error saving game state to Firebase:', error);
                return false;
            }
        }

        // Load the ENTIRE game state from Firebase
        async function loadGameStateFromCloud(pin) {
            try {
                const response = await fetch(`${FIREBASE_URL}/games/${pin}/gameState.json`);
                
                if (response.ok) {
                    const data = await response.json();
                    if (data) {
                        console.log('‚úÖ Game state loaded from Firebase:', pin);
                        return data;
                    }
                }
                return null;
            } catch (error) {
                console.error('‚ùå Error loading game state from Firebase:', error);
                return null;
            }
        }

        // Reconstruct game state with proper Card and Player objects
        function reconstructGameState(gameState) {
            const reconstructedGame = {
                players: gameState.players.map(playerData => {
                    const player = new Player(playerData.name);
                    player.hand = playerData.hand.map(cardData => new Card(cardData.value, cardData.type));
                    player.isDisqualified = playerData.isDisqualified;
                    player.hasFinished = playerData.hasFinished;
                    player.isPaused = playerData.isPaused || false;
                    player.pausedUntil = playerData.pausedUntil || 0;
                    return player;
                }),
                deck: gameState.deck.map(cardData => new Card(cardData.value, cardData.type)),
                discardPile: gameState.discardPile.map(cardData => new Card(cardData.value, cardData.type)),
                currentPlayerIndex: gameState.currentPlayerIndex,
                roundNumber: gameState.roundNumber,
                highCardPlayedThisRound: gameState.highCardPlayedThisRound,
                gameOver: gameState.gameOver,
                winner: gameState.winner,
                direction: gameState.direction
            };
            return reconstructedGame;
        }

        async function loadGameFromCloud(pin) {
            try {
                const response = await fetch(`${FIREBASE_URL}/games/${pin}.json`);
                
                if (response.ok) {
                    const data = await response.json();
                    if (data && data.pin) {
                        console.log('‚úÖ Game loaded from Firebase:', pin);
                        return data;
                    } else {
                        console.log('‚ùå Game not found in Firebase:', pin);
                        return null;
                    }
                } else {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
            } catch (error) {
                console.error('‚ùå Error loading from Firebase:', error);
                return null;
            }
        }

        async function removeGameFromCloud(pin) {
            try {
                const response = await fetch(`${FIREBASE_URL}/games/${pin}.json`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    console.log('‚úÖ Game removed from Firebase:', pin);
                } else {
                    console.error('‚ùå Error removing game from Firebase');
                }
            } catch (error) {
                console.error('‚ùå Error removing from Firebase:', error);
            }
        }

        // Real-time listener for Firebase updates
        let gameUpdateListener = null;
        let gameStateListener = null;

        function startRealTimeListener(pin) {
            if (gameUpdateListener) {
                stopRealTimeListener();
            }

            console.log('üîÑ Starting real-time listener for PIN:', pin);
            
            // Poll Firebase for lobby changes every 2 seconds
            gameUpdateListener = setInterval(async () => {
                try {
                    const updatedSession = await loadGameFromCloud(pin);
                    if (updatedSession && updatedSession.lobbyPlayers) {
                        // Check if player count has changed
                        if (updatedSession.lobbyPlayers.length !== gameSession.lobbyPlayers.length) {
                            console.log('üîÑ Lobby updated! New player count:', updatedSession.lobbyPlayers.length);
                            gameSession.lobbyPlayers = updatedSession.lobbyPlayers;
                            updateLobbyDisplay();
                        }
                        
                        // Check if game has started
                        if (updatedSession.gameStarted && !gameSession.gameStarted) {
                            gameSession.gameStarted = true;
                            stopRealTimeListener();
                            
                            // Initialize basic game state for non-host players using proper Player objects
                            game = {
                                players: updatedSession.lobbyPlayers.map(p => new Player(p.name)),
                                deck: [],
                                discardPile: [],
                                currentPlayerIndex: 0,
                                roundNumber: 1,
                                highCardPlayedThisRound: false,
                                gameOver: false,
                                winner: null,
                                direction: 1
                            };
                            
                            // Hide lobby and show game
                            document.getElementById('setupModal').style.display = 'none';
                            showMessage('Game started!', 'success');
                            updateDisplay();
                            
                            // Start listening for real game state from host
                            startGameStateListener(pin);
                        }
                    } else if (!updatedSession) {
                        console.log('‚ö†Ô∏è Game session no longer exists');
                    }
                } catch (error) {
                    console.error('‚ùå Error in real-time listener:', error);
                }
            }, 2000); // Check every 2 seconds
        }

        // Separate listener for game state during gameplay
        function startGameStateListener(pin) {
            if (gameStateListener) {
                stopGameStateListener();
            }

            console.log('üéÆ Starting game state listener for PIN:', pin);
            let lastTimestamp = 0;
            
            gameStateListener = setInterval(async () => {
                try {
                    const gameState = await loadGameStateFromCloud(pin);
                    if (gameState && gameState.timestamp && gameState.timestamp > lastTimestamp) {
                        // Don't update if this player just made the move
                        if (gameState.lastMoveBy !== gameSession.playerName) {
                            // Reconstruct Player objects properly from Firebase data
                            if (gameState.players) {
                                game.players = gameState.players.map(p => {
                                    const player = new Player(p.name);
                                    // Reconstruct Card objects in player's hand
                                    player.hand = (p.hand || []).map(cardData => new Card(cardData.value, cardData.type));
                                    player.active = p.active !== undefined ? p.active : true;
                                    player.isDisqualified = p.isDisqualified || false;
                                    player.hasFinished = p.hasFinished || false;
                                    player.isPaused = p.isPaused || false;
                                    player.pausedUntil = p.pausedUntil || 0;
                                    return player;
                                });
                            }
                            
                            // Reconstruct Card objects in deck and discard pile
                            game.deck = (gameState.deck || game.deck || []).map(cardData => new Card(cardData.value, cardData.type));
                            game.discardPile = (gameState.discardPile || []).map(cardData => new Card(cardData.value, cardData.type));
                            game.currentPlayerIndex = gameState.currentPlayerIndex || 0;
                            game.roundNumber = gameState.roundNumber || 1;
                            game.highCardPlayedThisRound = gameState.highCardPlayedThisRound || false;
                            game.gameOver = gameState.gameOver || false;
                            game.winner = gameState.winner || null;
                            game.direction = gameState.direction || 1;
                            
                            // Update display for all players
                            updateDisplay();
                        }
                        lastTimestamp = gameState.timestamp;
                    }
                } catch (error) {
                    console.error('‚ùå Error in game state listener:', error);
                }
            }, 1000); // Check every 1 second for faster gameplay
        }

        function stopGameStateListener() {
            if (gameStateListener) {
                clearInterval(gameStateListener);
                gameStateListener = null;
                console.log('‚èπÔ∏è Stopped game state listener');
            }
        }

        function stopRealTimeListener() {
            if (gameUpdateListener) {
                clearInterval(gameUpdateListener);
                gameUpdateListener = null;
                console.log('‚èπÔ∏è Stopped real-time listener');
            }
            stopGameStateListener();
        }

        // Alternative sharing method for GitHub Pages
        function generateShareableLink(pin) {
            const baseUrl = 'https://enochaseks.github.io/peakgame/';
            return `${baseUrl}?pin=${pin}`;
        }

        // Check for PIN in URL when page loads
        function checkUrlForPin() {
            const urlParams = new URLSearchParams(window.location.search);
            const pin = urlParams.get('pin');
            if (pin && pin.length === 4 && /^\d{4}$/.test(pin)) {
                document.getElementById('gamePin').value = pin;
                console.log('üîó PIN found in URL:', pin);
            }
        }

        // Card types
        const CardType = {
            REGULAR: 'regular',
            PEAK: 'peak',
            REVERSE: 'reverse',
            STAR: 'star',
            GOBLIN: 'goblin',
            PAUSE: 'pause'
        };

        // Card class
        class Card {
            constructor(value, type = CardType.REGULAR) {
                this.value = value;
                this.type = type;
            }

            toString() {
                if (this.type === CardType.PEAK) return 'Peak';
                if (this.type === CardType.REVERSE) return 'Reverse';
                if (this.type === CardType.STAR) return 'Star';
                if (this.type === CardType.GOBLIN) return 'Goblin';
                if (this.type === CardType.PAUSE) return 'Pause';
                return this.value.toString();
            }

            isPeakCard() {
                return this.type === CardType.PEAK;
            }

            canFinishOn() {
                // Special cards cannot be finished on
                if (this.isPeakCard() || this.isReverseCard() || this.isStarCard() || this.isGoblinCard() || this.isPauseCard()) return false;
                if (this.value >= 1 && this.value <= 4) return false;
                if (this.value >= 5 && this.value <= 6) return true;
                if (this.value >= 8 && this.value <= 10) return true;
                return false;
            }

            isReverseCard() {
                return this.type === CardType.REVERSE;
            }

            isStarCard() {
                return this.type === CardType.STAR;
            }

            isGoblinCard() {
                return this.type === CardType.GOBLIN;
            }

            isPauseCard() {
                return this.type === CardType.PAUSE;
            }
        }

        // Player class
        class Player {
            constructor(name) {
                this.name = name;
                this.hand = [];
                this.isDisqualified = false;
                this.hasFinished = false;
                this.isPaused = false;
                this.pausedUntil = 0;
            }

            addCard(card) {
                console.log(`üì• Adding card ${card.toString()} to ${this.name}'s hand`);
                console.log(`üë§ ${this.name} hand before: ${this.hand.length} cards`);
                this.hand.push(card);
                console.log(`üë§ ${this.name} hand after: ${this.hand.length} cards`);
                
                if (this.hand.length > 20) {
                    this.isDisqualified = true;
                    console.log(`‚ùå ${this.name} disqualified for having ${this.hand.length} cards`);
                }
            }

            addCards(cards) {
                for (let card of cards) {
                    this.addCard(card);
                }
            }

            removeCard(card) {
                const index = this.hand.findIndex(c => c.value === card.value && c.type === card.type);
                if (index !== -1) {
                    this.hand.splice(index, 1);
                    return true;
                }
                return false;
            }

            isActive() {
                return !this.isDisqualified && !this.hasFinished;
            }

            canTakeTurn() {
                if (!this.isActive()) return false;
                if (this.isPaused && Date.now() < this.pausedUntil) return false;
                
                // Auto-unpause if pause time has expired
                if (this.isPaused && Date.now() >= this.pausedUntil) {
                    this.isPaused = false;
                    this.pausedUntil = 0;
                }
                
                return true;
            }
        }

        // Game functions
        function createDeck() {
            const deck = [];
            // Add regular cards 1-10 (multiple copies to have enough cards)
            for (let copy = 0; copy < 4; copy++) {  // 4 copies of each number
                for (let i = 1; i <= 10; i++) {
                    deck.push(new Card(i, CardType.REGULAR));
                }
            }
            // Add 10 Peak cards
            for (let i = 0; i < 10; i++) {
                deck.push(new Card(0, CardType.PEAK));
            }
            // Add 8 Reverse cards
            for (let i = 0; i < 8; i++) {
                deck.push(new Card(0, CardType.REVERSE));
            }
            // Add 5 Star cards (removes Peak cards from others)
            for (let i = 0; i < 5; i++) {
                deck.push(new Card(0, CardType.STAR));
            }
            // Add 5 Goblin cards (gives bad cards to others)
            for (let i = 0; i < 5; i++) {
                deck.push(new Card(0, CardType.GOBLIN));
            }
            // Add 3 Pause cards (pauses other player for 2 minutes)
            for (let i = 0; i < 3; i++) {
                deck.push(new Card(0, CardType.PAUSE));
            }
            return shuffleDeck(deck);  // Now we have 71 total cards (40 regular + 10 Peak + 8 Reverse + 5 Star + 5 Goblin + 3 Pause)
        }

        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        function dealCards() {
            for (let player of game.players) {
                for (let i = 0; i < 7; i++) {
                    if (game.deck.length > 0) {
                        player.addCard(game.deck.pop());
                    }
                }
            }
        }

        function canPlayCard(card, lastCard = null) {
            // Special cards can always be played
            if (card.isPeakCard() || card.isReverseCard() || card.isStarCard() || card.isGoblinCard() || card.isPauseCard()) return true;
            if (!lastCard) return true;
            if (lastCard.isPeakCard() || lastCard.isReverseCard() || lastCard.isStarCard() || lastCard.isGoblinCard() || lastCard.isPauseCard()) return true;
            
            // Regular cards follow adjacency rules
            if (card.type === CardType.REGULAR && lastCard.type === CardType.REGULAR) {
                const diff = Math.abs(card.value - lastCard.value);
                return diff <= 1;
            }
            return false;
        }

        function canFinishOnCard(card, highCardPlayed = false) {
            if (card.isPeakCard()) return false;
            if (card.value >= 1 && card.value <= 4) return false;
            if (card.value >= 5 && card.value <= 6) return true;
            if (card.value >= 8 && card.value <= 10) return highCardPlayed;
            return false;
        }

        function isHighValueCard(card) {
            return !card.isPeakCard() && !card.isReverseCard() && card.value >= 8 && card.value <= 10;
        }

        async function playCard(playerIndex, cardIndex) {
            const player = game.players[playerIndex];
            const card = player.hand[cardIndex];
            
            if (!player || !card) {
                return false;
            }

            // Remove card from player's hand and add to discard pile
            const cardToRemove = player.hand.splice(cardIndex, 1)[0];
            game.discardPile.push(cardToRemove);
            
            showMessage(`${player.name} played ${cardToRemove}`, 'success');

            // Check if high value card
            if (isHighValueCard(cardToRemove)) {
                game.highCardPlayedThisRound = true;
                showMessage("High card played! Players can now finish on cards 8-10.", 'info');
            }

            // Handle Peak card
            if (cardToRemove.isPeakCard()) {
                handlePeakCard();
            }

            // Handle Reverse card
            if (cardToRemove.isReverseCard()) {
                handleReverseCard();
            }

            // Handle Star card
            if (cardToRemove.isStarCard()) {
                handleStarCard();
            }

            // Handle Goblin card
            if (cardToRemove.isGoblinCard()) {
                handleGoblinCard();
            }

            // Handle Pause card
            if (cardToRemove.isPauseCard()) {
                handlePauseCard(playerIndex);
            }

            // Check if player finished
            if (player.hand.length === 0) {
                if (canFinishOnCard(cardToRemove, game.highCardPlayedThisRound)) {
                    player.hasFinished = true;
                    showMessage(`üèÜ ${player.name} has finished the game!`, 'success');
                    updateDisplay();
                    checkGameOver();
                    return true;
                } else {
                    showMessage(`${player.name} cannot finish on ${cardToRemove}!`, 'error');
                    if (game.deck.length > 0) {
                        player.addCard(game.deck.pop());
                        showMessage(`${player.name} picks up a penalty card`, 'warning');
                    }
                }
            }

            // Move to next player
            nextPlayer();
            
            // Update the display immediately
            console.log('üîÑ Updating display...');
            updateDisplay();
            
            // Save game state to Firebase for all players
            if (gameSession.pin) {
                await saveGameStateToCloud(gameSession.pin, {
                    players: game.players.map(p => ({
                        name: p.name,
                        hand: p.hand,
                        active: p.active,
                        isDisqualified: p.isDisqualified,
                        hasFinished: p.hasFinished,
                        isPaused: p.isPaused,
                        pausedUntil: p.pausedUntil
                    })),
                    deck: game.deck,
                    discardPile: game.discardPile,
                    currentPlayerIndex: game.currentPlayerIndex,
                    roundNumber: game.roundNumber,
                    highCardPlayedThisRound: game.highCardPlayedThisRound,
                    gameOver: game.gameOver,
                    winner: game.winner,
                    direction: game.direction,
                    lastMoveBy: gameSession.playerName,
                    timestamp: Date.now()
                });
                console.log('üíæ Game state saved to Firebase after move');
            }
            
            console.log('‚úÖ Card play completed');
            
            return true;
        }

        function handlePeakCard() {
            const nextPlayer = getNextActivePlayer();
            if (nextPlayer && game.deck.length >= 5) {
                const cards = [];
                for (let i = 0; i < 5 && game.deck.length > 0; i++) {
                    cards.push(game.deck.pop());
                }
                nextPlayer.addCards(cards);
                showMessage(`${nextPlayer.name} must pick up ${cards.length} cards due to Peak card!`, 'warning');
                
                if (nextPlayer.isDisqualified) {
                    showMessage(`${nextPlayer.name} is disqualified for having over 20 cards!`, 'error');
                }
            }
        }

        function handleReverseCard() {
            game.direction *= -1;  // Flip the direction
            const directionText = game.direction === 1 ? 'clockwise' : 'counter-clockwise';
            showMessage(`üîÑ Direction reversed! Now playing ${directionText}`, 'info');
            console.log('üîÑ Game direction changed to:', directionText);
        }

        function handleStarCard() {
            console.log('‚ú® Star card played - removing Peak cards from other players');
            let totalPeakCardsRemoved = 0;
            
            game.players.forEach((player, index) => {
                if (index !== game.currentPlayerIndex && player.isActive()) {
                    // Find and remove all Peak cards from this player's hand
                    const peakCards = [];
                    for (let i = player.hand.length - 1; i >= 0; i--) {
                        if (player.hand[i].isPeakCard()) {
                            peakCards.push(player.hand.splice(i, 1)[0]);
                        }
                    }
                    
                    if (peakCards.length > 0) {
                        totalPeakCardsRemoved += peakCards.length;
                        showMessage(`‚ú® ${player.name} had ${peakCards.length} Peak card(s) removed!`, 'info');
                        console.log(`Removed ${peakCards.length} Peak cards from ${player.name}`);
                        
                        // Put the Peak cards back into the deck and shuffle
                        game.deck.push(...peakCards);
                        game.deck = shuffleDeck(game.deck);
                    }
                }
            });
            
            if (totalPeakCardsRemoved > 0) {
                showMessage(`üåü Star card removed ${totalPeakCardsRemoved} Peak card(s) from other players!`, 'success');
            } else {
                showMessage(`üåü Star card played, but no Peak cards were found to remove`, 'info');
            }
        }

        function handleGoblinCard() {
            console.log('üëπ Goblin card played - giving bad cards to other players');
            const badCards = [1, 2, 3, 4]; // Bad cards that can't be finished with
            
            game.players.forEach((player, index) => {
                if (index !== game.currentPlayerIndex && player.isActive()) {
                    // Give each other player a random bad card (1-4)
                    const badCardValue = badCards[Math.floor(Math.random() * badCards.length)];
                    const badCard = new Card(badCardValue, CardType.REGULAR);
                    player.addCard(badCard);
                    
                    showMessage(`üëπ ${player.name} received a ${badCardValue} card from the Goblin!`, 'warning');
                    console.log(`Gave ${player.name} a ${badCardValue} card`);
                    
                    if (player.isDisqualified) {
                        showMessage(`${player.name} is disqualified for having over 20 cards!`, 'error');
                    }
                }
            });
            
            showMessage(`üëπ Goblin card cursed all other players with bad cards!`, 'warning');
        }

        function handlePauseCard(currentPlayerIndex) {
            console.log('‚è∏Ô∏è Pause card played - choosing target player');
            
            // Find all other active players
            const targetPlayers = game.players.filter((player, index) => 
                index !== currentPlayerIndex && player.isActive()
            );
            
            if (targetPlayers.length === 0) {
                showMessage('‚è∏Ô∏è No players available to pause!', 'info');
                return;
            }
            
            // For now, pause the next player (in a real game, this could be a choice)
            const nextPlayer = getNextActivePlayer();
            if (nextPlayer) {
                // Set pause timer for 2 minutes (120 seconds)
                nextPlayer.pausedUntil = Date.now() + (2 * 60 * 1000);
                nextPlayer.isPaused = true;
                
                showMessage(`‚è∏Ô∏è ${nextPlayer.name} is paused for 2 minutes!`, 'warning');
                console.log(`Paused ${nextPlayer.name} until:`, new Date(nextPlayer.pausedUntil));
                
                // Start a timer to unpause the player
                setTimeout(() => {
                    if (nextPlayer.isPaused) {
                        nextPlayer.isPaused = false;
                        nextPlayer.pausedUntil = 0;
                        showMessage(`‚ñ∂Ô∏è ${nextPlayer.name} is no longer paused!`, 'info');
                        console.log(`Unpaused ${nextPlayer.name}`);
                        updateDisplay();
                    }
                }, 2 * 60 * 1000);
            }
        }

        function getNextActivePlayer() {
            const startIndex = (game.currentPlayerIndex + game.direction + game.players.length) % game.players.length;
            for (let i = 0; i < game.players.length; i++) {
                const playerIndex = (startIndex + (i * game.direction) + game.players.length) % game.players.length;
                console.log('Checking player index:', playerIndex);
                if (game.players[playerIndex].isActive()) {
                    return game.players[playerIndex];
                }
            }
            return null;
        }

        function nextPlayer() {
            const originalIndex = game.currentPlayerIndex;
            console.log('‚è≠Ô∏è Moving from player:', game.players[game.currentPlayerIndex].name);
            console.log('üß≠ Direction:', game.direction === 1 ? 'clockwise' : 'counter-clockwise');
            
            for (let i = 0; i < game.players.length; i++) {
                game.currentPlayerIndex = (game.currentPlayerIndex + game.direction + game.players.length) % game.players.length;
                const currentPlayer = game.players[game.currentPlayerIndex];
                if (currentPlayer.canTakeTurn()) {
                    break;
                } else if (currentPlayer.isActive() && currentPlayer.isPaused) {
                    // Skip paused player but show message
                    const remainingTime = Math.ceil((currentPlayer.pausedUntil - Date.now()) / 1000);
                    if (remainingTime > 0) {
                        showMessage(`‚è∏Ô∏è ${currentPlayer.name} is paused for ${remainingTime} more seconds`, 'info');
                    }
                }
            }

            console.log('‚è≠Ô∏è Next player is:', game.players[game.currentPlayerIndex].name);

            // Check if we completed a round (more complex with direction changes)
            const roundCompleted = (game.direction === 1 && game.currentPlayerIndex <= originalIndex) ||
                                 (game.direction === -1 && game.currentPlayerIndex >= originalIndex);
            
            if (roundCompleted) {
                game.roundNumber++;
                game.highCardPlayedThisRound = false;
                showMessage(`üîÑ Round ${game.roundNumber}`, 'info');
                console.log('üîÑ New round started:', game.roundNumber);
            }
        }

        function drawCard() {
            console.log('üÉè Draw card function called');
            const currentPlayer = game.players[game.currentPlayerIndex];
            
            console.log('üë§ Current player:', currentPlayer.name);
            console.log('üì¶ Cards in deck before draw:', game.deck.length);
            console.log('üé¥ Player hand size before draw:', currentPlayer.hand.length);
            
            if (game.deck.length === 0) {
                showMessage("No more cards in the deck!", 'error');
                console.log('‚ùå No cards left in deck');
                return false;
            }

            const card = game.deck.pop();
            console.log('üéØ Drew card:', card.toString());
            
            currentPlayer.addCard(card);
            console.log('‚úÖ Card added to player hand');
            console.log('üé¥ Player hand size after draw:', currentPlayer.hand.length);
            console.log('üì¶ Cards in deck after draw:', game.deck.length);
            
            showMessage(`${currentPlayer.name} drew a card: ${card}`, 'info');

            if (currentPlayer.isDisqualified) {
                showMessage(`${currentPlayer.name} is disqualified for having over 20 cards!`, 'error');
                console.log('‚ùå Player disqualified');
            }

            // Move to next player
            nextPlayer();
            
            // Update display immediately
            console.log('üîÑ Updating display after draw...');
            updateDisplay();
            console.log('‚úÖ Draw card completed');
            
            return true;
        }

        function checkGameOver() {
            const activePlayers = game.players.filter(p => p.isActive());
            const finishedPlayers = game.players.filter(p => p.hasFinished);

            if (finishedPlayers.length > 0) {
                game.gameOver = true;
                game.winner = finishedPlayers[0];
                showGameOver(`üéâ ${game.winner.name} wins!`);
            } else if (activePlayers.length <= 1) {
                game.gameOver = true;
                if (activePlayers.length === 1) {
                    game.winner = activePlayers[0];
                    showGameOver(`üéâ ${game.winner.name} wins!`);
                } else {
                    showGameOver("üòû Game ended with no winner.");
                }
            }
        }

        function showGameOver(message) {
            document.getElementById('gameOverTitle').textContent = 'Game Over!';
            document.getElementById('gameOverMessage').textContent = message;
            document.getElementById('gameOverModal').style.display = 'block';
        }

        function showMessage(message, type = 'info') {
            const messagesContainer = document.getElementById('gameMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `game-message message-${type}`;
            messageDiv.textContent = message;
            messagesContainer.appendChild(messageDiv);
            
            // Remove old messages
            const messages = messagesContainer.children;
            if (messages.length > 3) {
                messagesContainer.removeChild(messages[0]);
            }
            
            // Auto-remove message after 5 seconds
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.parentNode.removeChild(messageDiv);
                }
            }, 5000);
        }

        function updateDisplay() {
                // Update game info
            document.getElementById('roundNumber').textContent = game.roundNumber;
            document.getElementById('deckCount').textContent = game.deck.length;
            document.getElementById('highCardPlayed').textContent = game.highCardPlayedThisRound ? '‚úÖ' : '‚ùå';
            document.getElementById('currentPlayer').textContent = game.players[game.currentPlayerIndex]?.name || '-';
            document.getElementById('gameDirection').textContent = game.direction === 1 ? '‚Üª Clockwise' : '‚Ü∫ Counter-CW';

            // Update last played card
            const lastCard = game.discardPile && game.discardPile.length > 0 ? game.discardPile[game.discardPile.length - 1] : null;
            const lastCardElement = document.getElementById('lastPlayedCard');
            if (lastCard) {
                const cardElement = createCardElement(lastCard, -1, -1, true);
                cardElement.style.margin = '0 auto';
                lastCardElement.innerHTML = '';
                lastCardElement.appendChild(cardElement);
                console.log('Updated last played card to:', lastCard.toString());
            } else {
                lastCardElement.innerHTML = '<div class="card regular" style="margin: 0 auto; background: #ddd; color: #666;">No Card Yet</div>';
            }

            // Update players
            updatePlayersDisplay();

            // Update draw button
            const drawBtn = document.getElementById('drawBtn');
            const shouldDisable = game.deck.length === 0 || game.gameOver;
            drawBtn.disabled = shouldDisable;
            console.log('üÉè Draw button status:', shouldDisable ? 'disabled' : 'enabled', '(deck:', game.deck.length, 'cards, gameOver:', game.gameOver, ')');

            // Check for game over
            if (!game.gameOver) {
                checkGameOver();
            }
        }

        function updatePlayersDisplay() {
            const container = document.getElementById('playersContainer');
            container.innerHTML = '';

            const avatarIcons = ['üë§', 'üé≠', 'ü§ñ', 'üëæ'];
            const avatarColors = [
                'linear-gradient(135deg, #ff9a9e, #fecfef)',
                'linear-gradient(135deg, #a8edea, #fed6e3)', 
                'linear-gradient(135deg, #fbc2eb, #a6c1ee)',
                'linear-gradient(135deg, #74b9ff, #0984e3)'
            ];

            game.players.forEach((player, playerIndex) => {
                const seatDiv = document.createElement('div');
                seatDiv.className = 'player-seat';
                
                const avatarDiv = document.createElement('div');
                avatarDiv.className = 'player-avatar';
                
                if (playerIndex === game.currentPlayerIndex && player.isActive()) {
                    avatarDiv.classList.add('current-turn');
                }
                if (player.isDisqualified) {
                    avatarDiv.classList.add('disqualified');
                }
                if (player.hasFinished) {
                    avatarDiv.classList.add('finished');
                }

                // Create avatar icon
                const iconDiv = document.createElement('div');
                iconDiv.className = 'avatar-icon';
                iconDiv.style.background = avatarColors[playerIndex];
                iconDiv.textContent = avatarIcons[playerIndex];

                // Create player name
                const nameDiv = document.createElement('div');
                nameDiv.className = 'player-name';
                nameDiv.textContent = player.name;

                // Create card count
                const cardCountDiv = document.createElement('div');
                cardCountDiv.className = 'card-count';
                cardCountDiv.textContent = `${player.hand.length} cards`;

                // Create status indicator
                let statusText = '';
                if (player.hasFinished) {
                    statusText = 'üèÜ Winner!';
                    cardCountDiv.style.color = '#FFD700';
                } else if (player.isDisqualified) {
                    statusText = '‚ùå Out';
                    cardCountDiv.style.color = '#f44336';
                } else if (player.isPaused && Date.now() < player.pausedUntil) {
                    const remainingTime = Math.ceil((player.pausedUntil - Date.now()) / 1000);
                    statusText = `‚è∏Ô∏è Paused (${remainingTime}s)`;
                    cardCountDiv.style.color = '#ff9800';
                } else if (playerIndex === game.currentPlayerIndex) {
                    statusText = '‚≠ê Turn';
                    cardCountDiv.style.color = '#4CAF50';
                } else {
                    cardCountDiv.style.color = '#666';
                }

                if (statusText) {
                    const statusDiv = document.createElement('div');
                    statusDiv.style.fontSize = '0.8em';
                    statusDiv.style.fontWeight = 'bold';
                    statusDiv.style.marginTop = '3px';
                    statusDiv.textContent = statusText;
                    avatarDiv.appendChild(statusDiv);
                }

                // Create simplified hand display (just show a few cards as indicators)
                const handDiv = document.createElement('div');
                handDiv.className = 'player-hand';
                handDiv.id = `player-${playerIndex}-hand`;

                const lastCard = game.discardPile[game.discardPile.length - 1];
                
                // Show cards based on whether this is the logged-in player's own hand
                const isOwnHand = (player.name === gameSession.playerName);
                const cardsToShow = isOwnHand ? player.hand : player.hand.slice(0, 3);
                
                cardsToShow.forEach((card, cardIndex) => {
                    const isPlayable = isOwnHand && game.players && game.players[playerIndex];
                    const displayCard = isOwnHand ? card : createCardBack();
                    const cardElement = createCardElement(displayCard, playerIndex, cardIndex, false, isPlayable, !isOwnHand);
                    handDiv.appendChild(cardElement);
                });

                // If player has more than 3 cards and it's not own hand, show "..."
                if (!isOwnHand && player.hand.length > 3) {
                    const moreDiv = document.createElement('div');
                    moreDiv.style.fontSize = '0.8em';
                    moreDiv.style.color = '#666';
                    moreDiv.style.alignSelf = 'center';
                    moreDiv.textContent = '...';
                    handDiv.appendChild(moreDiv);
                }

                // Assemble avatar
                avatarDiv.appendChild(iconDiv);
                avatarDiv.appendChild(nameDiv);
                avatarDiv.appendChild(cardCountDiv);
                // Always show cards - either own cards (face up) or card backs (face down)
                avatarDiv.appendChild(handDiv);

                seatDiv.appendChild(avatarDiv);
                container.appendChild(seatDiv);
            });
            
            console.log('Players display updated - circular table layout');
        }

        function createCardBack() {
            // Create a card back object for other players' hidden cards
            return {
                value: 0,
                type: 'back',
                toString: () => 'üÇ†',
                isPeakCard: () => false,
                isReverseCard: () => false,
                canFinishOn: () => false
            };
        }

        function createCardElement(card, playerIndex, cardIndex, isLastPlayed = false, isPlayable = false, isCardBack = false) {
            const cardDiv = document.createElement('div');
            
            if (isCardBack) {
                cardDiv.className = 'card card-back';
                cardDiv.textContent = 'üÇ†';
                cardDiv.style.background = 'linear-gradient(145deg, #1a1a1a, #333)';
                cardDiv.style.color = '#666';
                cardDiv.style.cursor = 'default';
            } else {
                cardDiv.className = 'card ' + card.type;
                cardDiv.textContent = card.toString();
                
                if (isLastPlayed) {
                    cardDiv.classList.add('last-played');
                }
                if (isPlayable) {
                    cardDiv.classList.add('playable');
                    cardDiv.onclick = async () => {
                        await playCard(playerIndex, cardIndex);
                    };
                    cardDiv.style.cursor = 'pointer';
                }
            }
            
            return cardDiv;
        }

        async function createGame() {
            const playerName = document.getElementById('playerName').value.trim();
            if (!playerName) {
                alert('Please enter your name');
                return;
            }

            // Generate 4-digit PIN
            const pin = Math.floor(1000 + Math.random() * 9000).toString();
            
            const hostPlayer = {
                id: generatePlayerId(),
                name: playerName,
                isHost: true
            };
            
            gameSession = {
                pin: pin,
                isHost: true,
                playerName: playerName,
                playerId: hostPlayer.id,
                lobbyPlayers: [hostPlayer],
                gameStarted: false
            };

            // Save to cloud so others can join from different devices
            console.log('üíæ Saving game to Firebase with PIN:', pin);
            const saveSuccess = await saveGameToCloud(pin, {
                pin: pin,
                lobbyPlayers: gameSession.lobbyPlayers,
                gameStarted: false
            });
            
            if (!saveSuccess) {
                alert('Failed to create game. Please check your internet connection and try again.');
                return;
            }
            console.log('‚úÖ Game successfully saved to Firebase');

            showLobby();
            startRealTimeListener(pin); // Start real-time updates
            console.log('Game created with PIN:', pin);
        }

        async function joinGame() {
            const playerName = document.getElementById('playerName').value.trim();
            const pin = document.getElementById('gamePin').value.trim();
            
            if (!playerName) {
                alert('Please enter your name');
                return;
            }
            
            if (!pin || pin.length !== 4 || !/^\d{4}$/.test(pin)) {
                alert('Please enter a valid 4-digit PIN');
                return;
            }

            // Check if game session exists in cloud
            console.log('üîç Looking for game with PIN:', pin);
            const sessionData = await loadGameFromCloud(pin);
            if (!sessionData) {
                alert('Game not found! Please check the PIN and make sure the host has created the game.');
                console.log('‚ùå No game found for PIN:', pin);
                return;
            }
            console.log('‚úÖ Found game session:', sessionData);
            
            // Check if game is full
            if (sessionData.lobbyPlayers.length >= 4) {
                alert('Game is full! Maximum 4 players allowed.');
                return;
            }

            // Check if player name already exists
            if (sessionData.lobbyPlayers.some(p => p.name === playerName)) {
                alert('Player name already taken! Please choose a different name.');
                return;
            }

            // Add new player to existing session
            const newPlayer = {
                id: generatePlayerId(),
                name: playerName,
                isHost: false
            };
            
            sessionData.lobbyPlayers.push(newPlayer);
            
            // Update cloud
            await saveGameToCloud(pin, sessionData);

            // Set up local game session
            gameSession = {
                pin: pin,
                isHost: false,
                playerName: playerName,
                playerId: newPlayer.id,
                lobbyPlayers: sessionData.lobbyPlayers,
                gameStarted: false
            };

            showLobby();
            startRealTimeListener(pin); // Start real-time updates
            console.log('Joined game with PIN:', pin);
        }

        function generatePlayerId() {
            return 'player_' + Math.random().toString(36).substr(2, 9);
        }



        function showLobby() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('lobbyScreen').style.display = 'block';
            document.getElementById('gamePinDisplay').textContent = `PIN: ${gameSession.pin}`;
            
            // Update shareable link
            const shareUrl = generateShareableLink(gameSession.pin);
            document.getElementById('shareUrl').textContent = shareUrl;
            
            updateLobbyDisplay();
        }

        function updateLobbyDisplay() {
            const playersUL = document.getElementById('playersUL');
            playersUL.innerHTML = '';
            
            gameSession.lobbyPlayers.forEach(player => {
                const li = document.createElement('li');
                li.style.padding = '5px 0';
                li.innerHTML = `
                    <span style="display: inline-block; width: 20px;">${player.isHost ? 'üëë' : 'üë§'}</span>
                    ${player.name}
                    ${player.id === gameSession.playerId ? ' (You)' : ''}
                `;
                playersUL.appendChild(li);
            });

            // Update start button (only host can start, and need 4 players)
            const startBtn = document.getElementById('startGameBtn');
            const canStart = gameSession.isHost && gameSession.lobbyPlayers.length === 4;
            startBtn.disabled = !canStart;
            
            const waitingMsg = document.getElementById('waitingMessage');
            if (gameSession.lobbyPlayers.length < 4) {
                waitingMsg.textContent = `Waiting for ${4 - gameSession.lobbyPlayers.length} more players...`;
            } else if (!gameSession.isHost) {
                waitingMsg.textContent = 'Waiting for host to start the game...';
            } else {
                waitingMsg.textContent = 'Ready to start!';
            }
        }

        let lobbyPollingInterval = null;

        function startLobbyPolling() {
            // This function is now replaced by startRealTimeListener
            // Keeping for compatibility but redirecting to new function
            console.log('‚ö†Ô∏è startLobbyPolling is deprecated, using startRealTimeListener instead');
            startRealTimeListener(gameSession.pin);
        }

        function stopLobbyPolling() {
            // This function is now replaced by stopRealTimeListener
            console.log('‚ö†Ô∏è stopLobbyPolling is deprecated, using stopRealTimeListener instead');
            stopRealTimeListener();
            if (lobbyPollingInterval) {
                clearInterval(lobbyPollingInterval);
                lobbyPollingInterval = null;
            }
        }

        async function leaveLobby() {
            // Stop real-time updates
            stopRealTimeListener();
            
            // If host is leaving, clean up the game session
            if (gameSession.isHost && gameSession.pin) {
                await removeGameFromCloud(gameSession.pin);
            }
            
            document.getElementById('lobbyScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'block';
            
            // Clear fields
            document.getElementById('playerName').value = '';
            document.getElementById('gamePin').value = '';
            
            gameSession = {
                pin: null,
                isHost: false,
                playerName: '',
                playerId: null,
                lobbyPlayers: [],
                gameStarted: false
            };
        }

        async function startGameFromLobby() {
            if (!gameSession.isHost || gameSession.lobbyPlayers.length < 2) {
                alert('Need at least 2 players to start game');
                return;
            }

            // Update cloud to notify all players game is starting
            const sessionData = await loadGameFromCloud(gameSession.pin);
            if (sessionData) {
                sessionData.gameStarted = true;
                await saveGameToCloud(gameSession.pin, sessionData);
            }

            // Stop real-time updates and start the actual game
            stopRealTimeListener();
            startActualGame();
        }

        async function startActualGame() {
            // Only the host initializes the game state
            if (gameSession.isHost) {
                console.log('üéÆ Host initializing game state...');
                
                // Initialize game with lobby players
                const playerNames = gameSession.lobbyPlayers.map(p => p.name);
                
                game = {
                    players: playerNames.map(name => new Player(name)),
                    deck: createDeck(),
                    discardPile: [],
                    currentPlayerIndex: 0,
                    roundNumber: 1,
                    highCardPlayedThisRound: false,
                    gameOver: false,
                    winner: null,
                    direction: 1
                };

                dealCards();
                
                // Save initial game state to Firebase
                await saveGameStateToCloud(gameSession.pin, {
                    players: game.players.map(p => ({
                        name: p.name,
                        hand: p.hand,
                        active: p.active
                    })),
                    deck: game.deck,
                    discardPile: game.discardPile,
                    currentPlayerIndex: game.currentPlayerIndex,
                    roundNumber: game.roundNumber,
                    highCardPlayedThisRound: game.highCardPlayedThisRound,
                    gameOver: game.gameOver,
                    winner: game.winner,
                    direction: game.direction,
                    lastMoveBy: 'HOST_INIT',
                    timestamp: Date.now()
                });
                
                console.log('‚úÖ Initial game state saved to Firebase');
            } else {
                console.log('üéÆ Non-host waiting for game state...');
                // Non-host players wait and load game state from Firebase
                let attempts = 0;
                while (attempts < 10) {
                    const gameState = await loadGameStateFromCloud(gameSession.pin);
                    if (gameState && gameState.players) {
                        // Reconstruct Player objects properly
                        game = {
                            players: gameState.players.map(p => {
                                const player = new Player(p.name);
                                // Reconstruct Card objects in player's hand
                                player.hand = (p.hand || []).map(cardData => new Card(cardData.value, cardData.type));
                                player.active = p.active !== undefined ? p.active : true;
                                return player;
                            }),
                            // Reconstruct Card objects in deck and discard pile
                            deck: (gameState.deck || []).map(cardData => new Card(cardData.value, cardData.type)),
                            discardPile: (gameState.discardPile || []).map(cardData => new Card(cardData.value, cardData.type)),
                            currentPlayerIndex: gameState.currentPlayerIndex || 0,
                            roundNumber: gameState.roundNumber || 1,
                            highCardPlayedThisRound: gameState.highCardPlayedThisRound || false,
                            gameOver: gameState.gameOver || false,
                            winner: gameState.winner || null,
                            direction: gameState.direction || 1
                        };
                        console.log('‚úÖ Game state loaded from Firebase');
                        break;
                    }
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }

            // Set current player ID for card visibility
            gameSession.gameStarted = true;
            const currentPlayerIndex = game.players.findIndex(p => p.name === gameSession.playerName);
            if (currentPlayerIndex !== -1) {
                gameSession.currentPlayerIndex = currentPlayerIndex;
            }

            console.log('Game started from lobby:');
            console.log('Players:', game.players.map(p => `${p.name}: ${p.hand.length} cards`));
            console.log('Current player for this client:', gameSession.playerName);
            
            document.getElementById('setupModal').style.display = 'none';
            showMessage('Game started! Each player has 7 cards.', 'success');
            updateDisplay();
            
            // Start listening for game state changes
            startGameStateListener(gameSession.pin);
        }

        // Legacy function for compatibility
        function startGame() {
            startGameFromLobby();
        }

        function showSetup() {
            document.getElementById('setupModal').style.display = 'block';
            document.getElementById('gameOverModal').style.display = 'none';
        }

        function showGameState() {
            const activePlayers = game.players.filter(p => p.isActive()).length;
            const message = `Round: ${game.roundNumber}\nActive Players: ${activePlayers}\nCards in Deck: ${game.deck.length}\nHigh Card Played: ${game.highCardPlayedThisRound ? 'Yes' : 'No'}`;
            alert(message);
        }

        function toggleRules() {
            const panel = document.getElementById('rulesPanel');
            panel.style.display = panel.style.display === 'block' ? 'none' : 'block';
        }

        // Copy share link to clipboard
        function copyShareLink() {
            const shareUrl = document.getElementById('shareUrl').textContent;
            navigator.clipboard.writeText(shareUrl).then(() => {
                const button = event.target;
                const originalText = button.textContent;
                button.textContent = '‚úÖ Copied!';
                button.style.background = '#4CAF50';
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = '#2196F3';
                }, 2000);
            }).catch(() => {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = shareUrl;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                alert('Link copied to clipboard!');
            });
        }

        // Initialize game
        window.onload = function() {
            showSetup();
            checkUrlForPin(); // Check if PIN is in URL
            
            // Add PIN input validation
            const pinInput = document.getElementById('gamePin');
            const joinBtn = document.getElementById('joinBtn');
            
            pinInput.addEventListener('input', function() {
                const pin = this.value.trim();
                joinBtn.disabled = !(pin.length === 4 && /^\d{4}$/.test(pin));
            });
            
            // Allow only numbers in PIN input
            pinInput.addEventListener('keypress', function(e) {
                if (!/\d/.test(e.key) && !['Backspace', 'Delete', 'Tab', 'Enter'].includes(e.key)) {
                    e.preventDefault();
                }
            });
        };

        // Close modals when clicking outside
        window.onclick = function(event) {
            const setupModal = document.getElementById('setupModal');
            const gameOverModal = document.getElementById('gameOverModal');
            const rulesPanel = document.getElementById('rulesPanel');
            
            if (event.target === setupModal) {
                setupModal.style.display = 'none';
            }
            if (event.target === gameOverModal) {
                gameOverModal.style.display = 'none';
            }
            if (!event.target.closest('.rules-toggle') && !event.target.closest('.rules-panel')) {
                rulesPanel.style.display = 'none';
            }
        };
    </script>
</body>
</html>